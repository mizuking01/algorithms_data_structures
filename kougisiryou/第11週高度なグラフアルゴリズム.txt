データ構造とアルゴリズム第11週の講義を始めます。前回の第10週では、ここに挙げたグラフの基本について学びました。グラフには向こう有効重み付きグラフがありましたね。表現方法としては、隣接行列、隣接リストがありました。また、グラフの探索としては幅優先探索、深さ優先探索がありました。

ここで、幅優先探索と深さ優先探索についてまとめます。幅優先探索は、貝が存在するならば必ず発見できるという完全性、それから長さが最も短い経路を返すという最適性がありました。しかし、規模の大きな探索においては効率が悪いと言われています。

一方、深さ優先探索は、最短経路などの最適解が求まるかは保証されていません。しかし、平均的なケースでは、幅優先探索と比較して記憶領域の使用量が少ないことや、再帰アルゴリズムにより簡単に記述できる点が特徴です。構築法を求める場合にも使用できるといった利点もあります。

これは講義スケジュールです。今回の内容は探索問題の後半部分として、ミニマックス法、最短経路問題、ネットワークフローについてお話しします。

今回は、前回の探索を発展させて、最適な手を選ぶ方法や、最大の経路を選ぶ戦略的なアルゴリズムを扱います。まずは、ゲームAIでもよく使われているミニマックス法を紹介します。これは2人対戦型のゲーム、例えばリバーシや将棋、チェスのような状況で有効な戦略的アルゴリズムです。

この例はコンピューター対戦型リバーシ（オセロ）です。このゲームでは、盤面の評価方法を設定できます。評価方法は三つあります。一つ目はコマ数による評価です。自分のコマ数から敵のコマ数を引いた値を評価値とします。二つ目は、コマの位置による重み付け評価です。盤面の各マスに評価値を設け、自分のコマがあればその評価値を加算し、敵のコマがあれば減産します。そして、この合計値を評価値とします。

三つ目は着手可能数による評価です。自分のコマが置けるマスの数を評価値とします。同じ局面でも、この評価方法を変えると評価値は大きく変化します。コマ数だけでなく、位置や着手可能数も考慮することで、コンピューターの判断がより人間に近づいていきます。

次に、ミニマックス法による最善手の探索について説明します。ミニマックス法とは、自分と相手、例えばコンピューターと人間が交互に手を打つときに、相手が最善の手を打ってくると仮定し、その中で自分にとって最も有利な手を選ぶという考え方です。

現在の盤面がこのような場合、三手先まで可能性のある盤面を書いていきます。このような構造が出来上がります。これをゲーム木と言います。このゲーム木において、ノードであるここの部分が三手先となる局面になります。ミニマックス法では、まずこの三手先の評価値を求めます。評価値は先ほどの評価方法を利用して求めます。

この時、コンピューターにとって一番有利な手を採用します。つまり、この二つの局面では、評価値の高い方、例えばこちらをコンピューターの手とします。同様に、三番と五番を比較して、五番を採用します。

同じように五七と採用していきます。次に相手ですが、この場合は人間です。人間はコンピューターにとって一番不利な手を採用します。つまり、評価値が低い方を選びます。こちらも五と七だと、五を選びます。そして最後に、コンピューターの手番の部分ですから、自分にとって一番有利な手を採用します。つまり、評価値が三と五で高い五の方を採用するということです。

現在の盤面はここなので、この手を指すことになります。コンピューターの読み筋は結果的にこのようになっているということです。ミニマックス法では、自分の手番の時は評価値の最大値を採用します。一方、相手の手番の時は、評価値の最小値を採用することで決めていきます。そして、このように構造の下から上に向かって評価値を伝えていきます。

ミニマックス法は、探索と評価を組み合わせて、限られた時間で最善の手を導くための重要なアルゴリズムです。次は最短経路問題です。最もコスト、例えば運賃や時間、距離などの少ないルートを調べるときに使います。現実世界でもナビアプリや地図アプリのルート探索などで活躍している分野です。

このように液を濃度としてルートを書いたりします。これを重み付き有向グラフで考えていきます。例えば、都市Aから都市Eへの最短経路は？という問題があります。この場合、A→D→C→Eの順に行くのが最短で、その時のコストは8となります。

このような簡単なグラフでは良いのですが、グラフが複雑になると目で見てもわからなくなり、すべてのルートを調べると非常に時間がかかるという問題が起こります。そこで、ダイクストラ法を使っていきたいと思います。その前に最短経路問題を定義します。

まず、重み付き有向グラフが入力となります。Vは頂点、Eは辺、Cは重みになります。また、頂点の数をN、辺の数をMとします。これが入力となります。そして、二つの頂点間の最小距離が出力となります。

この最短経路問題にはいくつかのバリエーションがあります。一つは、ある一頂点から他の一頂点への一対1の距離です。二つ目は、ある頂点から他のすべての頂点への一体、他の距離です。三つ目は、すべての頂点からすべての頂点への距離です。今回はこの二つ目の一体、他の距離について考えたいと思います。

次にダイクストラ法の概要について説明します。ダイクストラ法は、視点から調べる範囲をじわじわと広げながら距離を求めていくというグリーディーなアプローチです。距離が最小の設定を見つけて、その周囲を更新していきます。

これはダイクストラ法の最短経路アルゴリズムです。ダイクストラ法は、視点からの最短距離を順に確定させていくアルゴリズムです。まず、この1から3のステップは初期化の部分です。最初に、Gの各頂点Vについて、Vが保持する距離を無限大とします。また、視点の保持する距離をゼロとします。それから、チェック済みの頂点集合Xを空にします。

次に、ステップ4に進みます。ステップ4は、すべての頂点がチェック済みになるまで以下の処理を繰り返します。

まず、チェック済みでない頂点の中で保持する距離が最小の頂点をUとします。このUをチェック済みとし、Xに追加します。そして、頂点Uから未チェック頂点vに向かう各辺について、Uが保持する距離プラス辺の重みがvの保持する距離よりも小さい場合、Vが保持する距離を更新します。つまり、より短い経路が見つかった場合は、頂点の記録を差し替える処理を行います。

なお、ダイクストラ法は正の重みのみを扱います。負の重み、マイナスの重みがあると使用できないことに注意してください。次のスライドからは、具体的な例を使ってダイクストラ法の動作を説明します。

まず、ステップ1から3の初期化により、視点Aの距離をゼロ、それから各頂点の保持する距離を無限大と置きます。次にアルゴリズムのステップ4を実行します。1回目のループでは、まず、頂点Aの距離が最小なので、Aをチェック済みとします。そして、チェック済みのAから到達できる頂点BとDの距離を見直します。Bでは無限大とこの距離4を比較して無限大を4に更新します。Dも同じように、Dの距離を8に更新します。

これが更新した結果です。BとDはまだチェック済みではありませんが、今わかっている最短距離を頂点に記録しています。これで1回のループが終わります。次は2回目のループです。次に距離が短いのはBなので、Bをチェック済みとします。そして、Bから出ている辺を確認して、CとDの距離を見直します。Cは無限大なのですが、Cに到達する距離が11となりますので、この11の方を採用して更新します。

Dの場合はBからのルートを考えると4と9で13となります。この13と8を比較すると、もともとあった8の方が小さいので、更新はせずそのままにしておきます。これが更新を終了した時のグラフです。Cは更新されていますが、Dは前のままとなっています。

3回目のループでは次に距離の小さいDをチェック済みとします。そしてDの先にあるCとEの距離を見直します。Cはもともと11ですが、Dからの距離、つまり8足す2は10となりますので、比較すると10の方が小さいため、こちらの方に更新します。それからEの方はもともと無限大でしたが、Dからの距離8足す7で15となりますので、こちらが小さいです。なので、Eは15に変更をします。

距離を更新するとこのようになります。4回目のループでは、次に距離の小さいCをチェック済みとします。そしてCの先にあるEの距離を見直します。

シーからの距離は10足す4で14となります。もともとあった15と比較すると14が小さいので、Eの距離を14に更新します。これが更新した後のグラフとなります。5回目のループでは、最後のEをチェック済みとします。これですべての頂点の最短距離が確定しました。赤で示した経路が各頂点への最短経路を表現しています。

ここで、ダイクストラ法を整理しましょう。ダイクストラ法は、最短距離と最短経路を求めることができます。ダイクストラの最短経路アルゴリズムの命題は、チェック済み頂点は視点からの最短距離を保持することです。これにより、各頂点への最短経路も同時に計算できます。

計算時間は、Nが頂点の数、Mが辺の数とすると、ステップ1、3でオーダーのN、ステップ2はオーダーの1、ステップ4は繰り返し回数がN回で、ステップ4の3は総実行回数がオーダーのMとなります。そしてステップ4の1はデータ構造によって異なります。単純なデータ構造を用いた場合の総実行回数はオーダーのNの二乗、ヒープを用いた場合はオーダーのM log Nとなります。

したがって、総計算時間は、単純なデータ構造を用いた時にはオーダーのN二乗プラスM、ヒープを用いた場合はオーダーのM log Nとなります。このように、用いるデータ構造に計算時間が依存しています。

次は、ネットワークフローの問題です。ネットワークフローとは、ネットワーク上の流れ（フロー）をモデル化したものです。流れとは、例えば水道網における実際の水の流れ、インターネットにおけるデータの流れ、道路網における交通の流れなどが想定されています。

ネットワークフローでは最大流問題があります。SからTまで流すことができる流量の最大値とその最大の流量を与える流し方Fを求めるという問題です。ここでSは出発点、Tは終点を指します。

例を示します。これは水道のパイプ網を表しています。Sは入り口で、Tは出口となります。そして辺の数字はその辺（パイプ）が持つ最大の容量を示しています。このフローでは途中で水を貯められない構造になっています。

このような状態の中で、各辺にどれだけ水を流せば流量を最大化できるか、最大の量を出口に届けられるかという問題を考えます。ネットワークフローの問題は、どのルートを通すかだけでなく、どのくらいの量を通すかという量的な最適化も考えます。

ここでフローが満たす性質をまとめます。まず、FのUVは辺UVに流す水の量を示します。それから、フローには三つのルールがあります。一つ目は歪み対称性です。任意の頂点UVに対して、このような式が成り立ちます。つまり、逆方向のフローはマイナスと見なすということです。

二つ目のルールはフロー保存則です。SとT以外の任意の頂点Uに対して、このような式が成り立ちます。これは、頂点Uに入ってきた量と出ていく量が等しいことを表しています。

三つ目のルールは容量制約です。任意の頂点UVに対して、このような式が成り立ちます。つまり、各辺の容量Cをフローは超えないということです。

これら三つのルールを守りながら、どうすれば最大限に水を流せるかを考えるのがネットワークフローの問題になります。次にカットについて説明します。エスティーカットというのは、エスとティー、つまり入り口と出口を分離する線を引くことです。

例えば、このように線を引いたとします。ここでカットの容量を考えます。カットの容量というのは、カット上をSからTに流せる流量の最大値となります。したがって、Sから流せる量は16と10、これを合わせた26がこの丸一のカットの最大値になります。

同じように丸二のところでカットすると、これは12と13足して25になります。三のようにカットすると、少し複雑ですが、10と8と7と11があるので、合わせて36となります。四のようにカットすると、11と13があり、カットの容量は11足す13で24となります。

ここで、最大流量と最小カットの定理について説明します。2位のカットC2、位のフローFに対して、Fの流量はカットCの容量よりも小さいか等しいという関係が成立します。また、等式が成り立つようなカットとフローが存在します。この式から、最大流量はカットの容量の最小値と等しいと言えます。つまり、先ほどの例では、この例では、四でカットした24が最大流量になるということです。

ここで、最大流アルゴリズムの概要を紹介します。このアルゴリズムは、適当なフローからスタートし、追加できる流量を順次追加していく方法です。以下を計算しながら、フローFを順次更新していきます。

一つ目は残余容量です。現時点でのフローと容量との差を求めており、この残余容量の分だけまだ余裕があるということです。二つ目は残余グラフです。残余グラフは、残余容量を重みにした新しいグラフです。そして、三つ目は拡張可能経路です。これは残余グラフにおけるSからTへの経路を表しており、つまり、まだ流せる余地のある経路のことです。

次に、最大流アルゴリズムについて説明します。ステップ1と2は初期化の部分です。まずFをゼロフロー、つまりフローFをすべてゼロに初期化します。また、フローFに対する残余グラフをGFとします。ステップ3は、実際の処理を行うところです。残余グラフGに拡張可能経路がある限り、この処理を繰り返していきます。

まず、残余グラフにおいて拡張可能経路Pを求めます。そして、P上の辺の最小残余容量の分だけFを増やします。その後、残余グラフGFを計算し直します。これを繰り返して、残余グラフGFに拡張可能経路がなくなった場合には、Fを最大フローとして出力します。

まず、これが元々のグラフです。下がステップ1により、フローFをゼロフロー、つまり流量をゼロとした状態のグラフになります。ここでループ1回目、ステップ3より残余グラフと拡張可能経路はこのようになります。

残余グラフはそのままです。そして、拡張経路は例えばS→C→Tという経路を選んだとします。ここで拡張可能経路、S→C→Tにおいて容量が10と3なので、10が小さい。つまり最小残余容量は10となります。そこでフローをこのように10に増やして更新します。

次に2回目のループでは、このようにフローFが10に更新されると、残余グラフはSからCは10から10を引いてゼロ、CからDは13から10を引いて3、残余容量があるということになります。次に拡張可能経路をこのように考えると、この中で最小の値は11です。これがフローの値になります。よって、SからA→B→Tとなる経路に関しては、フローが11となり、合わせてTに入る流量は21となります。

このように、11のフローに対して残余グラフもこの部分が変更になっています。16から11を引いて、52から11を引いて、11から11を引いてゼロというふうになっています。次に拡張可能経路を考えます。次はS→A→B→C→Tというふうに経路を考えます。

この中で一番小さいのは1ですので、フローはこの1を10に足して12、ここで11に1を足して12、こちらは1になります。そして12に1を足した11に更新されます。このように更新されたフローにより、残余グラフはさらに数字が変更されています。そしてまた新しい拡張可能経路を探します。ここで一番小さいのが2ですので、フローはこの2を足して14、23と変わります。この状態で拡張可能経路はもうありませんので、先ほどのフローが最終となります。流量は24ということになります。

先ほどの回はこのようなフローグラフになりましたが、別の回もあります。例えば最初の流れをS→A→B→Dと取った場合は、最終的にこのような残余グラフが出来上がり、フローのグラフはこのようになります。前のと少し違うのがわかります。しかし、流し方は違っても最終的な流量は24と同じになります。

最後にまとめです。今回はミニマックス法とダイクストラ法、ネットワークフローについて学習しました。ダイクストラ法では、最短経路と最短距離を求めることができました。一方、ネットワークフローでは、最大流問題に取り組んで最大フローを求めました。いずれもグラフ構造を活用して最適解を探索するアルゴリズムです。ダイクストラ法による最短経路アルゴリズムのポイントは、チェック済み頂点は視点からの最短距離を保持することです。

各頂点への最短経路も同時に計算でき、計算時間はオーダーのN²プラスMまたはオーダーのM log Nです。Nは頂点の数、Mは辺の数となっています。この計算時間の違いは用いるデータに依存しています。次にネットワークフローの計算時間ですが、ネットワークの容量が整数値の場合は、オーダーのM×M maxとなります。Mというのは辺の数、M maxは最大流の値です。そうでなくて、一般的な場合はオーダーのN³やオーダーのNM²で求められます。

以上で講義を終わります。お疲れ様でした。