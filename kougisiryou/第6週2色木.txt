データ構造とアルゴリズム第6週の説明は有明高専の加藤が担当します。これは本コースの講義スケジュールです。今回は第6週、動的探索問題とデータ構造について説明します。これまで基本的なデータ構造として、配列、連結リスト、ハッシュ表、二分探索木 、スタック、ヒープを紹介し、それぞれについて探索、挿入、削除の手間を考察しました。今回は、動的探索問題とデータ構造について説明します。

この動的探索問題とは、探索対象のデータが動的に変化する問題のことです。この「動的に変化する」というのは、データの挿入や削除が頻繁に行われる状態のことです。この動的探索問題を解決するために、動的なデータ構造を用います。動的データ構造とは、処理の途中で構造が変化するデータ構造です。これは、前に学習した連結リストや二分探索木 などでも実現できますが、ここではもっと効率の良い高度な動的データ構造として、動的ハッシュ表と平衡二分探索木 （二色木）の話をしていきます。

まず、動的探索問題の例を考えましょう。例えば、データベースプログラムを設計・開発するとします。このデータベースでは、1億エントリーのデータを想定しています。つまり、データ数Nは1億個となります。そして、このデータベースは、データの追加や削除が頻繁に行われるとします。この時、データベースプログラムは正しく動作するのはもちろん、速度も求められます。それでは、まずデータ構造を検討してみましょう。

最初に、配列を使うことを考えます。ここの「配列順序なし」というのは、順序関係がない配列のことです。この場合、逐次探索をしますので、第3週で学習したように探索はオーダーのN、挿入は数字が示す場所にデータを格納するので定数オーダー、削除はオーダーのNになります。

次に、配列に登録したデータに順序がある場合、探索では2分探索が使えますので、オーダーのlog Nの手間で済みます。しかし、データ挿入の場合は、挿入場所を開けるために、またデータ削除の場合は削除した場所に詰めるために、最悪の場合、すべてのデータを一つずつずらさなければならないことがありますので、ここはオーダーのNになってしまいます。

次に、オーダーNとオーダーlog Nの関係を見てみます。先ほどの1億個のデータNを、毎秒十億命令のコンピューターで処理をさせると、オーダーのNとオーダーのlog Nでこれだけの違いがあります。もしオーダーのNの手間がかかるならば、すぐにシステムがパンクしてしまうことがわかります。

そこで、動的なデータ構造としてまず動的ハッシュ法を紹介します。動的ハッシュ法は、第3週で学習したハッシュ法の拡張版で、データの追加や削除が頻繁に行われる場合に対応しています。動的ハッシュ法は、データXの格納位置をハッシュ関数で求めます。ここでMはハッシュ表Sのサイズです。このハッシュ表のサイズは、データ数Nの1.5倍から2倍ぐらい取ります。そしてXは格納したいデータで、Iはハッシュ関数で求めた値です。

ハッシュ関数はゼロからM引く一の整数を返す関数になっています。次にデータの挿入についてです。最初にデータを登録する時や、処理の途中でデータを追加する時には、ハッシュ関数で求めた値Iを使ってハッシュ表にデータを格納します。もし衝突が起こった場合、つまり異なるデータXで同じハッシュ関数の値になった場合は、その次の位置から空きを探して、空いたところに格納します。

次にデータ探索ですが、これもハッシュ関数で求めた値を利用して、その位置から順次探索をしていきます。ここまでは第3週で説明したハッシュ法と同じです。

次にデータの削除について見てみます。データの削除は、データを探索して削除するということですが、データの削除を行うとき、ハッシュ表から該当データを削除するだけで問題がないか考える必要があります。この場合の問題として、削除後の問題があります。例えば、データが1, 44, 32, 3, 17で、ハッシュ関数がデータを10で割った余りだとします。それで、実際に配列に挿入してみると、4の時はハッシュ関数により4の場所にこの4を入れますが、その次の14は、ハッシュ関数でまた4になります。ただし、数字の4のところにはすでにデータが入っているので、隣の空いている5のところに14を格納します。

こういった状態の中でデータ4を削除します。そうすると、4が空きになります。ここで4を削除した後のハッシュ表では、14を探索する際には14のハッシュ関数の値は4なので、4のところを見て空きコマだったため、14の探索に失敗として返してしまいます。このように、削除跡をどう扱うかというのが問題になります。

この削除跡の問題の対策として、最初からの空きマークと削除後の空きマークを区別する方法があります。例えば、4を削除します。この時に4のところに柵などのマークをつけます。そして、探索時にはこの柵のあるマスは空きとみなさず、挿入時にはこの柵のあるマスは空きとみなすというふうに場に応じて対応を変えます。ただし、この柵のマークが増えてくると効率が低下します。その時にはハッシュ表を定期的に再構成する必要があります。

先ほどはハッシュ表をこのように配列だけを使って実装しましたが、その他のやり方としてハッシュ表を配列と連結リストを組み合わせて実装する方法があります。これをチェーン法、または分離連鎖法と言います。参考までに簡単に説明しておきます。

先ほどと同じ例ですが、このようにハッシュが一致したデータは連結リストを利用して格納します。また、データを削除した場合も、矢印の付け替えだけで済むので、先ほどのような問題は起こりません。

次の話に入る前に、動的データ構造の良し悪しについて考えます。動的探索問題では、探索、挿入、削除の操作を頻繁に行います。この三つの操作がバランスよく効率よく行えるかどうかを考えてみます。まず配列ですが、高速化には順序を維持する必要があります。順序を維持することで、オーダーのlog Nの検索ができます。しかし、挿入や削除する場合は、一つずつずらす必要があり、どうしてもオーダーNの壁があります。また、データ数が固定しているのも問題です。

次に連結リスト、一方向のリストの場合、どの操作もポインターを先頭からたどる必要があり、これも結果的にオーダーNの壁があります。それから二分探索木 。これは平均的に木の高さであるオーダーのlog Nで探索、挿入、削除ができます。

しかし、木構造のバランスが崩れると、最悪オーダーのNの手間がかかります。ここで木構造のバランスが崩れないように工夫してみましょう。その話の前に、まず二分探索木 について復習します。二分探索木 は、例えばこのように、たかだか二つの子を持つ2分木になっています。

そして二分探索木 の各節点 における大小関係は、親の節点 が黄色で示されています。この黄色の親の節点 よりも左側にある部分木に関しては、親の値よりも小さくなります。今度は親の右側にある部分木。これは親の値よりも大きくなっています。

このルールを守っているのが二分探索木 です。平衡二分探索木 はバランスを維持する仕組みを備えた二分探索木 で、バランスが崩れそうになると補正をかけます。平衡二分探索木 としてはAVL木と赤黒木の二つがよく使われます。

この平衡二分探索木 は基本的には、まず二分探索木 と同様に挿入や削除を行います。その後、バランスの崩れ具合をチェックして、必要なら簡単な変形操作を行ってバランスを微調整します。このバランスを調整する方法として、一重回転と二重回転があります。

それではまずこのAVL木について紹介します。AVL木は、以下の平衡条件を満たす二分探索木 です。AVL木の平衡条件は二つあります。一つ目は、二つの子を持つ各節点 において、左部分木の高さと右部分木の高さがたかだか1しか異ならないということです。

もう一つは、一つの子しか持たない節点 において、その子は葉節点 であるということです。ちなみに、AVLはソビエト連邦、現在のロシアの数学者アデルソン＝ベルスキーとランディスのイニシャルから名付けられています。

AVL木は常に最もバランスが良く、探索など、いかなる処理もオーダーのlog Nでできると保証されています。しかし、現場では現在、次に説明する赤黒木が使われることが多いようです。赤黒木はAVL木ほど厳密にバランスは保たれていませんが、実装が比較的簡単です。

次に赤黒木について説明します。赤黒木は、赤黒木平衡条件を満たす二分探索木 のことです。探索アルゴリズムは二分探索木 と同じになります。また、赤黒木はAVL木ほどではありませんが、ある程度バランスの取れた木ができます。赤黒木の特徴ですが、この図のように、節点 が赤と黒の二色で色付けされています。このため、赤黒木は別名「赤黒木」とも呼ばれています。

この後の説明の都合上、子ポインタがヌルの時はそこに空の葉が存在すると考えるとします。この図では、これが空の葉です。次に、赤黒木平衡条件について説明します。赤黒木平衡条件は五つあります。ここに条件が書いてありますが、このRB0というのは「レッドとブラック」、つまり赤と黒の意味で、赤黒木の条件を表しています。RB0は、どの内部節点 も二つの子を持つということです。

このように、すべて二つの子を持っています。次にRB1の条件ですが、各節点 は赤または黒のいずれかの色になっています。次のRB2の条件は、空の葉に関してはすべて黒になっています。

そして、RB3の条件ですが、赤節点 の子は両方とも黒になります。このように黒になっています。次のRB4の条件ですが、根から葉までのどの経路も同じ数の黒の節点 を含みます。この例では、例えば左側を行くと、50、70、4からの葉節点 で3。

右側を行くと、57、8、17からの葉節点 で3、どのルートを通っても黒の節点 は3となります。つまり、黒節点 だけ見ればこれは平衡銀になっています。バランスが取れています。それから、ここの赤節点 の子は両方とも黒というのは親と子の関係で、赤赤と続くことはないということです。

次に、二色木の高さについて考えてみます。N個のデータを含む二色木の高さは、オーダーのlog Nです。ここで根から葉までの経路に含まれる黒節点 の節点 数をHとおきます。このHは、RB4の条件によりどの経路でも同じ数になります。

次に、根から葉までの経路に含まれる赤黒全部の節点 数というのはH以上2H以下となります。特に赤節点 の個数が黒節点 の数よりも小さいか、または等しいということになります。これはなぜなら、葉節点 は黒節点 だからです。

これより、二色木の節点 の数Nというのは、2のH-1乗-1より大きく、または2の2H-1乗-1より小さいか等しいという、そういうNの値になります。この範囲より。

根から葉までの経路に含まれる黒節点 の数Hというのは、このような式で表されます。つまり、2分のlog Nよりも大きいか等しい、またはlog Nよりも小さいか等しいという範囲になります。それでは、二色木のデータ挿入について基本手順を説明します。まずステップ1として、データを挿入します。通常の二分探索木 に対するデータ挿入と同じアルゴリズムを用いてデータを挿入します。

ステップ2、データ挿入後の二色木がRB0からRB4の5つの条件を満たすならば、挿入操作が終了します。そうでない場合、平衡条件を満たさないならば調整が必要です。

ここでは、二色木平衡条件を満たすように木を変形していきます。まずステップ1として、データを挿入します。通常の二分探索木 への挿入方法で、データを入れます。例えば、90を挿入する時にはこの部分に挿入します。これは黒節点 の下になっています。

また別の例では65を挿入。そうしてみると、今度は左側の赤節点 の下に入ります。データを黒節点 の下に挿入する場合と、赤節点 の下に挿入する場合では、その後の処理が異なりますので、このように二つの場合に分けて考えたいと思います。

次はステップ2。まず黒節点 の下へ挿入した場合を考えます。黒節点 の下へ挿入した場合、90を挿入した場合は補正の必要がありません。これは5つの平衡条件を満たしています。なので、そのままでいいです。挿入した節点 は赤色とします。

同じステップ2ですが、赤節点 の下へ挿入した場合を考えます。これは結構大変です。赤節点 の下へ挿入した場合は、平衡条件を満たしませんので補正の必要が出てきます。例えば、65を挿入した時、ここを赤にすると赤赤となり、ここにあるRB3の条件、赤節点 の子は両方とも黒という条件に反します。

それでは、ここを黒にするとどうかというと、根から葉までの黒節点 の数が1, 2, 3, 1, 2, 3となってしまいます。他のところはこのように1, 2, 2なので、RB4の条件、根から葉までのどの経路も同じ数の黒節点 を含むという条件に反してしまいます。よって補正をする必要があります。

この補正の方法として、一重回転や二重回転があります。どちらもバランスを保つための変形に利用されます。それではまず、一重回転について説明していきます。一重回転はこのように、10を親の節点 20の場所に10の子ごと移動します。そして20は右の方に回転させてずらします。そうすると、このようになります。

このように回転しても、親子の大小関係は崩れていません。これは今度は20を10のところの節点 に持ってくる、そして回転させるということで元に戻ります。このように双方向変換ができます。このように一重回転しても二分探索木 の条件は満たしていますので、これを利用して補正変形ができます。

次に二重回転について説明します。例えば、20を二重の親の10の場所に一重回転で移動します。するとこうなります。ここで平衡条件を確認するんですが、まだそれでも条件を満たしていないバランスが悪ければ、さらに変形をします。今度は二重を二重の親の3重のところに移動させ、回転させるということをします。

するとこのようになります。これで平衡条件を満たしていれば、変形は終了ということになります。このように二重回転しても、数字の大小を見てもらうと分かるように、二分探索木 の条件は満たしています。

先ほどは一重回転や二重回転、バランスを保つための変形について説明しました。それではステップ2で、さようなら調整する場合で、前の例のように赤色の節点 の下に65を挿入する場合を考えます。この場合、RB3かRB4のどちらかの条件に反していますので、65を移動させます。

65を親の節点 59のところに回転させ、さらにその65を71のところに回転させます。このように二重回転させると、この図のようにバランスが保たれます。

次はステップ2で必要なら調整という場面において、赤節点 の下へ新しいデータを挿入する。こういう時の一般的な話をします。例えば、65を新しいデータとして挿入する場合、その親は赤の59です。その親の兄弟というのがここの場所になりますが、これが赤か黒かで場合分けをします。この親の兄弟というのは、65から見たら叔父にあたります。叔父のところが赤か黒かで場合分けをするということです。

それでは赤節点 の下へ挿入した時に叔父が赤である場合、この時を考えます。親節点 の兄弟は赤の時は、これはその親と叔父の色を黒に変えます。挿入した65は赤に変えます。

その上も必要なら、同様に色を変えていきます。これにより、それぞれの根から葉までの黒節点 の個数が同じになります。次に、叔父が黒の場合を考えます。このように、親節点 の兄弟が黒の場合は4つのパターンがあります。

このように親の位置と子の位置が左側にある場合や右側にある場合、それから親が左、そしてその右の子にある場合と親がここにあって子が左側にある場合、このように4つのパターンがあるのですが、それをこのような形でAとBの二つの場合に分けています。

Aの中の左の図と右の図は左右対称になっています。Bの方も同じで、AとBのそれぞれ左の方の図を利用して説明していきます。まずAの場合ですが、これは赤節点 の左の子に新しいデータを追加しています。このXの叔父は黒色になっています。この時、Xを黒にすると部分Aの高さが一つ増えてしまいます。つまり、RB4の条件に反してしまいます。

それではXを赤にするとどうかというと、赤節点 同士が赤赤と親子になってしまいますので、これはRB3の条件に違反することになります。そのため、追加するデータXが親節点 のUの位置に来るように一重回転をさせます。このように、一重回転をすることによって、条件をすべて満たすことになります。つまり、赤節点 の左の子に新しいデータを挿入する場合で、叔父の節点 が黒の場合は一重回転によって補正をします。これは左右対称なものも同じようにできます。

一方Bの場合は赤節点 Uの右側の子に新しいデータを追加しています。ここで叔父は黒です。この時、Xを黒にすると部分Bの高さが一つ増えてしまいますので、RB4の条件に違反してしまいます。また、Xを赤にすると、赤赤と赤節点 同士が親子になってしまいますので、RB3の条件に違反しています。

そこでまず追加するデータXが親節点 の位置に行くように回転をして、さらにそのXがさらに上のWの位置に移動するように回転をします。つまり、二重回転を行います。つまり、赤節点 の右側の子にデータを挿入する場合で、叔父が黒の時は二重回転することによって補正をすることができます。これも左右対称のものは同じようにできます。

今まで話したのは、二色木の挿入アルゴリズムの場合、分けについてです。まず、黒節点 の下に新しいデータを挿入する場合には、補正の必要はありません。ここで挿入完了となります。次に赤節点 の下に新しいデータを挿入する場合は補正の必要があります。ここで親節点 の兄弟、つまり叔父の節点 が赤であれば色の変更、必要ならさらにさかのぼって色の変更をしていきます。

次に親節点 の兄弟、つまり叔父の節点 が黒の場合、場合に応じて一重回転または二重回転をして変形を行います。次に二色木からデータを削除する場合を考えます。二色木からデータを削除する場合の基本方針は、これも挿入の時と同じで、ステップ1として、とりあえず削除。通常の2分探索木に対するデータ削除と同じアルゴリズムを用いてデータを削除します。

次にステップ2、データ削除の後の二色木が平衡条件RB0からRB4を満たすならば、削除操作は終了します。一方、平衡条件を満たさないならば調整が必要です。二色木平衡条件を満たすように木を変形していきます。それでは、例を用いながら、二色木からデータ削除するときのことを考えます。

二色木からデータを削除するとき、次の三つの場合が考えられます。まず一つ目、節点 Xの二つの子がともに空の葉である場合です。例として節点 の4とか17、34、5、19、87がこの場合にあたります。次、場合において節点 Xの一方の子が空の葉である場合、節点 71がこの場合に当てはまります。この片方だけが空の葉になっています。3つ目、節点 Xの二つの子がともに空の葉でない、つまりこの図で言うと、例えば57とか二つの項がちゃんとあります。57とか22とか80とか14、これらが場合3に当てはまります。

この三つの場合について分けて話をしていきます。まず、この場合、1をちょっと飛ばして、場合2から考えていきます。それでは、場合2の節点 Xの一方の子が空の葉の時を考えます。例として、この71を削除するとします。71はこのように一方の子節点 だけが空の葉になっています。

まず71を削除します。そして、空の子で71を置き換えます。この時に空の節点 59の色は赤になります。そうなると、ここが80と59が赤赤となってRB3の条件を満たさないので、この59の節点 の色を黒に変更します。これで補正はおしまいになります。次に。

場合3について、節点 Xの二つの子がともに空の葉でない時を考えます。例として57のところですね。57を削除することを考えます。まず最初に57を削除します。そして57の直前、キーを求めます。直前キーというのは、前回お話をしたように削除した節点 の左の部分キーのうち最大の要素、この中では34になります。これが直前キーとなります。これを削除した設定に移動します。そして、ここにあった直前キー34を削除します。直前キーの右の子は空ですので、この場合は次に話す場合、両方とも空の葉、もしくは片方だけが空の葉の補正を適用します。

最後に場合1、節点 Xの二つの子がともに空の葉の時を考えます。この時、さらに二つの場合に分けられます。場合1の1というのは節点 Xが赤節点 です。例えば、この4の節点 のような状態です。場合1の2というのは節点 Xが黒節点 、つまり87のような状態の時です。例えば、場合1の1の例として59を削除することを考えます。場合1の1は簡単です。これは単に59を削除します。これは調整は不要になります。

次は場合1の2の場合です。これは削除する節点 が黒節点 の時です。例えば87を削除するとします。まずこの87を削除するのですが、これは黒節点 を削除したということで、黒節点 の数がマイナス1となり、バランスが悪くなります。それを回避するために一重回転をして補正をします。

今までの話をまとめます。今回は動的探索問題とデータ構造について説明しました。動的探索問題では、探索対象のデータが動的に変化します。つまり、データの挿入や削除が頻繁に行われる状況です。この問題に対応する動的データ構造として、動的ハッシュ表の話と平衡二分探索木 の話をしました。

特に平衡二分探索木 は前回話した二分探索木 の拡張版で、バランスの考え方や補正の方法などを組み込んだものになっています。通常の二分探索木 は、探索、挿入、削除は平均オーダーのlog Nですが、バランスが悪い木になった場合には最悪オーダーのNかかってしまいます。

また、データ挿入削除の順序によっては効率が下がってしまうものでした。平行条件を加えた平衡二分探索木 に関しては、ここで挿入や削除をする場合、まずは通常の二分探索木 のように挿入削除をとりあえずしておいて、で、必要ならば平行条件を満たすように調整、補正をしていきます。

こうしてバランスの良い二分探索木 を常に保っている状態ですので、探索、挿入、削除は平均最悪ともにオーダーのlog Nでできます。ただし、アルゴリズムは複雑になっています。以上で説明を終わります。お疲れ様でした。