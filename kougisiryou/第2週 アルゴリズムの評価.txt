それでは、アルゴリズムとデータ構造の第2回授業を始めたいと思います。前回のポイントは、アルゴリズムとデータ構造の概念を理解してもらうことと、アルゴリズムの性能の良し悪しを評価するための尺度として、陸王機法を使い、オーダーによる評価方法を学んだことです。

今日は、引き続きアルゴリズムの良し悪しを具体例で見ていき、アルゴリズム作成のガイドラインについても説明します。わかりやすいアルゴリズムを書くことは、生成AIでプログラミングを行う際にも重要です。AIにとっても人間にとってもわかりやすいアルゴリズムを作成するためにはどうすればよいかを、皆さんに理解してもらうことが目的です。

講義ホームページにアクセスして、アルゴリズム作成のガイドラインも確認できます。第2週の講義資料とともに、このガイドラインについても後で触れたいと思います。それでは、進めていきましょう。

さて、早速アルゴリズム作成のガイドラインについて説明します。プログラムの本質的な処理手順を簡潔に表現することで、プログラミングをより系統的にし、作業や保守作業を容易にすることができます。これにより、さまざまな利点を得ることができます。ここに書いてある三つの項目は、昔から変わらない基本的なポイントです。

この講座の前提となっている生成AIの活用から考えると、ガイドラインに基づいてアルゴリズムを書いてもらうことで、生成AIに対して皆さんの意図を正確に伝え、より適切なプログラムを自動生成してもらうことが期待できます。そのため、このアルゴリズム作成のガイドラインを守ることが重要です。

いくつかのアルゴリズムの記述例も示しているので、参考にしてみてください。最初の部分がそれぞれのプログラムの仕様であり、この部分がこのプログラムで使用されるデータ構造です。

さらに、プログラムでは週ごとに四桁の値を決めるなどの処理がありますが、これが個別のサブルーチンに対応しています。個別のサブルーチンのアルゴリズムも記述されているので、それを見て理解してもらえればいいと思います。

アルゴリズムの記述例もいくつか挙げていますが、前回の授業でも説明したように、アルゴリズムは有限で終わらなければなりません。また、アルゴリズムの各操作は、誰が実行しても同じ結果が得られるように書かなければなりません。これらは基本的な条件です。

その上で、アルゴリズムの各ステップは、仕様で使われている概念や用語を使って記述することが求められます。プログラミング言語の用語を使って記述することは避け、概念レベルでの整合性を保つことが重要です。

記述に漏れや余分な記述がないように注意してください。また、アルゴリズムの各ステップは、できるだけ単純なプログラムで記述できるようにしますが、アルゴリズムの一ステップをプログラムの一行に対応させる必要はありません。

基本的には、アルゴリズムの一ステップを書いたら、プログラムでは5行程度書いても全く問題ありません。むしろ、その程度の抽象度であればちょうど良いということです。アルゴリズムは人間を対象として書かれるものであり、プログラムはコンピューターを対象として書かれます。そのため、抽象度に差があります。

変数はすべてデータ構造として定義し、それを使ってアルゴリズムで参照することが基本的なルールです。また、変数名はその変数が保持する情報を説明する具体的な名前を付け、他の名前は使わないように注意します。

基本的な制御構造として、ブロック構造や条件判定、繰り返し処理（ルーチン）などを使用して記述します。これにより、構造化プログラミングが実現できます。例えば、N項目の条件に基づき、どの条件が成立するかによって処理内容を切り替える複雑な条件も、このような形で記述できます。

繰り返し処理には、while文やfor文を使って反復を記述します。典型的なパターンはこのようになっており、それに従って書くことを推奨します。サブルーチンは、意味のある処理を一まとまりとして記述するために使用します。

いくつかの注意事項がありますので、アルゴリズム作成のガイドラインを一通り目を通しておいてください。

残りの時間を使って、アルゴリズムの良し悪しについて、もう少し具体的な例を使って説明したいと思います。例えば、あなたは証券会社のセールスマンだとしましょう。株を買うと儲かるということをアピールしたいわけです。株には値動きがあり、これが魅力の一つです。

例えば、最初の月は4円で4000円、次の月は2000円、そして次の月は6000円というように、株価には値動きがあります。基本的に、例えばこのタイミングで買って、このタイミングで売った場合、買値は2000円、売値は5000円なので、利益は3000円となります。

逆に、高いところで買って安いところで売ると損をすることになります。このように、最大の利益を得るためには、いつ買っていつ売るかが重要です。では、利益が最大になるタイミングを株価のデータから求めたいという問題を考えてみます。

この問題を解こうと思った場合、一番シンプルな方法は、各月の株価を配列に格納し、買う月（i）と売る月（j）の組み合わせをすべて求め、その差の最大値を探す方法です。

具体的には、例えば月0で買って、月1で売る、月0で買って月2で売る、月0で買って月3で売るといった感じで、まず月0で買った場合にどこで売るかを検討します。その後、月1で買ってどこで売るか、月2で買ってどこで売るかと、すべての組み合わせについて利益を求めます。

すべての組み合わせにおける利益を計算し、最も利益が大きいところを求めることで、最大の利益を得るタイミングを見つけることができます。

今の考え方をアルゴリズムに直したのがこれです。利益の最大値をゼロに設定し、解析はゼロからN-2まで行います。売りの月は買った月の次の月からN-1までです。これを繰り返すことで、二重ループにより買い月と売り月のすべての組み合わせをチェックし、それぞれの利益が最大値より大きければ更新します。

このアルゴリズム1の1です。買い月と売り月の組み合わせは、0、1、2、3...7まで行き、次に12、13、14、17まで行きます。株を買った月と株を売った月の組み合わせについて、順番に調べるわけです。

最初の解析では、売り月は1から7までなので、最初のループは7回繰り返します。買い月を1つ増やすと、売り月は2から7までになるので、次は6回繰り返します。このように、繰り返し回数はだんだん少なくなり、最後は1回になります。

アルゴリズムのオーダーを求めると、最初と最後のステップはそれぞれ1回実行されるため、オーダーは一定です。外側のループはN回繰り返され、内側のループは最も多くても7回、最も少なくて1回繰り返されます。平均で言うと、内側のループはN/2回繰り返されます。

ループ内で行われる処理（利益の計算、比較、更新）はすべて定数時間で済むため、オーダーは1です。これをすべて合わせると、最初と最後はオーダー1、外側のループはN回、内側のループはN/2回、ループ内の処理はオーダー1です。したがって、最終的なオーダーはNの二乗となります。

このようなアルゴリズムにおいて、最も重要なのはループの部分です。ループがあることで、その部分の実行時間が長くなることが最大の問題になります。そのため、ループの回数を減らす工夫を考えます。

このアルゴリズムでは、外側のループと内側のループがあります。特に内側のループが一番時間がかかるので、ここで行う処理をできるだけ減らすことが重要です。具体的には、もともと二重ループ内で行われていた処理（例えば、2の3や2の4など）を外側のループに移動させ、内側のループの外で処理を行うようにします。

これにより、引き算や更新処理の回数を削減することができます。結果的にパフォーマンスが改善される可能性があります。また、売り月と買い月をひっくり返すことで、さらに改善できることもあります。売り月と買い月を逆転させた後、利益の計算などを内側のループの外に出してしまうというアプローチです。

このように、ループ変数を入れ替える技法もありますが、これで改善される場合もあります。ただし、残念ながら今回のアルゴリズム（アルゴリズム1.1）は総当たり法であり、内側のループから処理を外部に移動しても、ループ変数を入れ替えても、最終的にはオーダーNの二乗という計算量は変わりません。

次に、さらにこのアルゴリズムを改善できないか検討してみます。

実は、この方法がうまくいくのです。どうするかというと、最安値を保持する変数を導入し、それまでの最安値を保持します。各売り月に対して最安値を計算し、ここで計算した最安値がこれまでの最安値よりも安くなった場合、それを更新するという処理を加えます。

これを実行すると、実はパフォーマンスが向上します。なぜかというと、アルゴリズムのポイントは最安値を用いて、その最安値を調べることにあります。

この方法の一番大きなポイントは、三番目の部分で、外側のループはそのまま残りますが、内側のループがなくなる点です。この変更により、最初のステップ1とステップ2は定数時間で実行できます。外側のループは1からN-1まで繰り返すので、N-1回の繰り返しになります。

ステップ3の1から3までは定数オーダーで実行できます。最後の一文、ステップ4も定数オーダーで実行可能です。これらを合わせると、ステップ1はオーダー1、ステップ3はオーダーN、ステップ4もオーダー1です。最終的にトータルでオーダーNとなります。

このように、アルゴリズム1.4はオーダーNで実行できることがわかります。

例えば、1日8時間で1分ごとにデータを取る場合や、1年分の株価データを取る場合、オーダーNのアルゴリズムではこの計算を速く行えます。逆に、Nの二乗（オーダーN²）のアルゴリズムでは、計算に5分もかかることになり、圧倒的な差が開きます。

これは、前回も少し紹介したHornerの方法に関する話です。この方法では、N次の多項式を効率的に計算するため、係数a₀からaₙまでとXの値X₀を入力し、N次の多項式の値を効率よく計算します。

まず、律儀にやる方法では、X₀や係数の部分を入力し、P(X₀)を求めます。その後、AIにX₀をI回かけて、その結果を順次P(X₀)に加えていき、最終的にP(X₀)の値を返すという方法です。

これが律儀な方法ですが、実行するとまずステップ1は入力データが1つなので、定数オーダーで進みます。ステップ2では、N+1個のデータが入力されるのでオーダーNとなり、ステップ3は定数オーダーで進みます。ステップ4では、繰り返し回数がN+1回で、AIにX₀をI回かける処理が必要です。この繰り返しは平均的にN/2回行われます。加算部分は定数時間で済むため、最終的にP(X₀)を返すのも定数時間でできます。

トータルで見ると、ステップ1はオーダー1、ステップ2はオーダーN、ステップ3はオーダー1、ステップ4はN+1回繰り返し、トータルではオーダーN²となります。

これが従来の方法の結論です。それに対して、前回紹介したオーナーの方法を採用すると、最初にX₀とanを入力し、P(X₀)をanとします。その後、IをN-1から0まで変えながら、AIを入力し、P(X₀)にX₀を1回かけてAIを加える処理をN回繰り返します。これにより、最終的に多項式の値を効率的に計算することができます。

オーダー評価をすると、ステップ1、2、3は定数オーダーで済みます。ステップ4では繰り返し回数がN回ですが、4-1と4-2は両方とも定数時間で実行できます。

最終的に、ステップ1、2、3は定数オーダーで、ステップ4はループがN回で、ループの中は定数時間で実行されるため、トータルでオーダーNになります。

先ほどのナイーブな方法と比較すると、オーダーN²だったものがオーダーNに下がるため、劇的に速くなります。例えば、N項の数値データが配列に格納されている場合、IとJの値を調整して、aのIからaのJまでの区間和が最大になるようにIとJを求める問題を考えます。配列には正と負の要素が混在していると仮定しましょう。

一見、意味がわからない問題かもしれませんが、結局これは区間和を求める問題です。それに対して、区間ゼロからIに対する区間和をTᵢと定義します。そうすると、aのIからaのJまでの和は、TⱼからTᵢを引いたものだとわかります。

実際、この区間和を求めるためには、T₀からTₙまでのTᵢの値を計算して配列に格納し、その後、TᵢはTᵢ₋₁にaᵢを加えるだけです。そして、Tⱼ - Tᵢの最大値を求めれば、区間和の最大値が求められます。この方法は、株取引のアルゴリズムと同じです。

株取引のアルゴリズム1.1は総当たりのナイーブなアルゴリズムで、オーダーN²がかかりますが、少し工夫すれば、アルゴリズム1.4のようにオーダーNで計算できます。

実は、この区間和の最大値を求めるアルゴリズムもオーダーNで計算できるのです。Tᵢの値を計算して配列に格納する処理もオーダーNで実行可能です。工夫を加えることで、計算が効率的にできるということです。

株式売買による利益計算やN次多項式の計算では、総当たり法を使うとN二乗のオーダーがかかりますが、少し工夫すればオーダーNでできることがわかります。

アルゴリズムの世界では、うまい性質を見つけ、それを活用することでアルゴリズムの実行効率を劇的に高めることができます。これからの授業では、そういった効果的な工夫を学びます。

アルゴリズムを勉強することで、こうした工夫をたくさん知ることができます。それを理解していると、プログラムの実行速度やメモリ消費量を劇的に改善できることがわかります。

今後のアルゴリズムとデータ構造の授業を通じて、これらの技術を思い出し、プログラミングに活かしてもらいたいと思います。これで今日の話は終わりにします。
