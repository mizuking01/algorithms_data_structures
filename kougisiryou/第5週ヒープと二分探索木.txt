データ構造とアルゴリズム第5週の説明は有明高専の加藤が担当します。これは本コースの講義スケジュールです。第5週は前回に引き続き基本的なデータ構造について説明します。今回はヒープと二分探索木 について紹介します。

コンピュータープログラミングで使われる基本的なデータ構造を網羅することになります。まず、ヒープの話から始めたいと思います。ヒープはスタックやキューと違って、現在蓄えられているデータの中で値が最も大きいものを簡単に取り出せるようにしたデータ構造です。

一般に一元配列や連結リストにデータを蓄えていた場合、最大値を取り出そうとすると、オーダーのNの手間がかかります。もちろん、2分探索を利用すれば、最大値の取り出しはオーダーのlog Nで済みますが、データの挿入にオーダーのNがかかってしまいます。なぜなら、順番に並べる必要があるからです。

それに対して、このヒープは賢いデータ構造になっていて、新しいデータを挿入する時もオーダーのlog  Nでできます。どうやったらそれができるかというと、この木（ツリー）構造を利用します。それでは、まず木構造の用語を説明します。

木構造はこのような形をしたデータ構造です。この黄色い丸が節点 、またはノードと呼ばれるところです。ここのデータはこの節点 に保存されています。そして、節点 と節点 の間をつないでいるのが枝、もしくはエッジと呼ばれるものです。

枝でつながれた節点 の上の方を親、下の節点 を子と言います。これで親子関係を表しています。この木構造というのは、どの子どもから見ても、親は一人しかいません。逆に親から見ると、子どもは複数いる場合もあります。

これがこの木構造の大きな特徴です。この木構造の中で一番上にある節点 をルート、または根節点 と言います。このルートの上には親はいません。一方、この一番下の方の子供のことを葉、もしくはリーフと呼びます。

リーフ節点 は親はいますが、自分よりも下の子はいないという状態です。それでは、この木構造を用いてヒープを定義します。ヒープを定義する際にはいくつかの条件があります。一つは2分木であるということです。

2分木とは、各節点 にはたかだか2個の子供しかいないという構造です。例えば、72の節点 の子は35と47の2つ、35の子供は18と29の2つ、このようにたかだか2個の子供しかいない形になっています。

2つ目の条件は、親のデータの値は子供のデータよりも大きいということです。例えば、72が親だとします。子のデータは35と47で、親のデータの方が大きいです。同じように、47に着目してみると、この数字は32と13です。ですので、親のデータの方が大きいということになります。

3つ目の条件は、左詰めすることによって隙間なくデータを配置できることです。これらの条件により、木構造の高さはデータ数Nに対してlog Nで抑えられます。

この性質をうまく使うことによって、最大値を求める操作も新しいデータを追加する操作もlog  Nのオーダーでできるように工夫してあります。次に、ヒープを実装するときに配列を使う方法について説明します。ここに示してあるのは、先ほどと同じヒープです。

これを配列に格納する時にどうするかを考えます。まず、節点 の値は配列の一番目に入れます。節点 の子供はこの添え字の2Kと2K+1の位置に置くというルールを決めておきます。そうすると、A1の子はA2とA3に格納します。なので、A1には72、A2には35、A3には47が入ります。同じように、A2の子はA4とA5になります。なので、A4に18、A5に29が入ります。

同じように、A3の子はA6とA7、A4の子はA8とA9に入ります。こうすることによって、配列に隙間なく配置をすることができます。ヒープを使ってデータを保持するときには、このように配列を用いてデータを配置することにより、隙間なくデータを配置できるということになります。

この特徴を最大限に生かしてヒープの操作をしていきます。ヒープにおける操作としては二つあります。一つはデータの取り出しです。節点 のデータが最大値なので、最大値を求める場合には節点 のデータを取り出せばよいことになります。ただし、取り出すとその位置が開いてしまうので、ヒープを作り直す必要があります。

もう一つは、新しいデータを挿入したいとき、どこに入れるのが一番良いかを考える必要があります。この二つについてうまく実現する方法が必要になります。次に、その方法について説明します。

これからヒープへのデータの挿入例を示します。例えば、このヒープに46を挿入することを考えます。とりあえず、最後尾、ここですね。29の下の最後尾に46を挿入します。ここを見ると、親が29、子が46となり、この場合、ヒープ条件を満たしていません。

ヒープ条件というのは、親のデータはこのデータよりも大きいというものです。これを満たしていなければヒープとは言えませんので、ここは29と46を交換します。交換した結果がこのようになります。こうなると、29と46のところはヒープの条件を満たしています。しかし、今度は35と46がヒープの条件を満たさなくなってしまいました。そこで、ここも交換をします。これが35と46を交換した結果です。

次に、この46と72を確認します。この場合は46の親が72でデータの値が大きいので、これはそのままで問題ありません。これですべてヒープ条件を満たしましたので挿入完了となります。つまり、今の話をまとめると、一般的なルールとして、まず挿入したいデータを最後尾に追加し、ヒープ条件を満たしていなければ、親子を交換してヒープ条件を満たすようにします。

次に、データの挿入の効率について考えます。最悪の場合を考えると、木構造の一番下から根まで順次交換していくことになります。一回の交換操作は比較とデータ交換ですので、定数のオーダーでできます。次に繰り返しの回数ですが、データ数がNの完全に分岐した高さなので、これはlog  Nで押さえられます。よって、新しいデータを追加する操作の効率はオーダーのlog Nになります。

次に、ヒープからのデータの取り出し方について説明します。問題としては、ヒープから最大値を取り出し、その最大値の部分を削除したいということです。考え方はここに書いてありますが、例を使いながら説明していきます。まず、根のデータ、これが最大値になります。ここでは72です。これを取り出します。

取り出して72を削除するのですが、ここに空きができてしまいますので、最後尾のデータ、ここでは92が最後尾になります。これを暫定的に根の節点 に置きます。そして、あとはヒープの条件に合うように親子間で必要に応じて交換をしていきます。実際にこの例でやってみましょう。

これがデータの取り出しの例です。最初に最大値である72を取り出します。そうするとここが空っぽになりますので、最後尾にある92をこちらに持ってきます。そして92とその子にあたる35を比べます。これはヒープ条件「親の方が値が大きい」というのには当てはまっていませんので、交換が必要です。

右側の子もヒープ条件を満たしていないため、ここで35と47、どちらと交換すればよいかということになるのですが、ルールとしては大きい方、つまり47と交換します。交換した結果がこのようになります。ここで92と35を交換してはいけません。そうすると、他のところで狂いが生じます。必ず、この度のうち大きい方と交換するようにしてください。

これが92と47を交換した結果ですが、さらにこの92とその下の子32と13をそれぞれ見ていきます。どちらもヒープ条件に合っていないため、交換が必要です。これもまた2つの数を見比べて32の方が大きいので、大きい32と92を交換します。その結果がこのようになります。

これでもうこれ以上比べるところはありませんので、これで調整完了となり、これが新たなヒープとなります。次はヒープのデータ取り出しの効率について考えます。最悪の場合、木の根節点 から一番下まで順次交換していかなければなりません。一回の交換操作は2回の比較とデータの入れ替えでできるため、定数のオーダーになります。

データ数がNの完全に分岐した高さは log  Nで抑えられますので、データを取り出すときの効率というのはオーダーの log  Nになります。

まとめると、ヒープはデータの挿入も取り出しも、どちらもオーダーの log  Nで処理できます。このヒープを活用したものがヒープソートと呼ばれる並べ替えのアルゴリズムです。このアルゴリズムは、まず最初に空のヒープを用意します。そして、入力された各データをヒープに順番に挿入していきます。

すべてのデータの挿入が済んだら、ステップ3に移ります。ヒープから最大値を取り出して、それを表示します。それをヒープが空になるまで繰り返します。これによって、データの大きい順に並べ替えができます。

次に計算量を見てみたいと思います。空のヒープを用意するのは定数オーダーです。それから、ステップ3の「ヒープが空でない限り処理を繰り返す」というのはデータ数N回繰り返します。そして、ヒープから最大値を取り出し表示するというのは、先ほどの話からオーダーの log  Nとなります。

次に、ステップ2のところですが、これは各データをヒープに挿入しますので、その繰り返し回数はN回と、ヒープへの挿入としてオーダーの log  N、これが計算量となります。まとめると、ヒープソートのアルゴリズムの効率はオーダーのN log  Nとなります。これは並べ替えのアルゴリズムの中では効率の良いものになっています。

次は二分探索木 の話をします。二分探索木 はバイナリーサーチツリーとも呼ばれ、これは2分探索に適したデータ構造になっています。例えば、このようなデータの並びを2分探索するとします。まず、中央の7を見て、調べたい値と比較します。調べたい値が7より前にあれば、その前の方の中でまた中央にある3と比べます。そして、調べたい値が前にあればまた1の方を、後ろにあれば4の方をというふうに調べる範囲を半分ずつにして比較をしていく方法です。

これをよく見ると、このような2分木に実質的になっています。高さ系の二分探索木 は、2のK-1乗個のデータを保持することができます。二分探索木 の高さはデータ数Nに対してオーダーの log  Nとなっています。

先ほどの二分探索木 はこのような形になっていましたが、通常はこのように根を上の方にして書きます。二分探索木 はこのように各節点 での大小関係が決まっています。この黄色が親の節点 です。親の節点 よりも値が小さいものは左の方にあります。左の子は親よりも小さいデータが集まっています。

そして、親のデータよりも大きいデータを持つ子供は右の方に集まっています。このように、左の子の値よりも親の値が大きく、親の値よりも右の子の値が大きいということになります。二分探索木 はこのように大小関係を持っています。このような特徴があるので、二分探索木 上でのデータ探索は以下のようなアルゴリズムで実現できます。

まず最初に、根からスタートします。この7からスタートです。一番下の節点 に到達するまで、2の1乗のステップから2の3乗のステップを行います。例えば、現在見ている節点 が3だとします。3が調べたいデータと一致していれば、検索成功として終了します。この検索したい値が現在の節点 3よりも小さいならば、左の子に移ります。そうでなければ右の子に移ります。そしてまた調べるわけですが、葉点に到達しても調べたい値が見つからなかったら、検索失敗として返します。

最悪の場合は葉点まで行きます。そうすると、二分探索木 の高さはデータ数Nに対してオーダーの log  Nですから、データ探索アルゴリズムの効率もオーダーの log  Nになります。

次に、二分探索木 の中で最大値と最小値を探す問題を考えます。例えば、このような二分探索木 があるとして、最大値を求める場合には、このように根から始めて、右の子だけをたどれるだけたどっていきます。最後にたどり着いた8の節点 のところが最大値となります。同じように、根から始めて、今度は左の子をたどれるだけたどります。

では、節点 まで行ったところが最小値ということになります。何度も言いますが、二分探索木 の高さはデータ数Nに対してオーダーの log  Nになりますので、最大値最小値を求めるアルゴリズムの効率もオーダーの log  Nになります。次は二分探索木 へのデータの挿入について説明します。

二分探索木 は決められた条件を満たさないといけないので、値を挿入すべき場所を最初に探索して、その探索した場所にデータを挿入すればいいということになります。例えば12を挿入する場合、最初に12と7を比べて12が大きいので右の方に行きます。

次に11と12を比べて12の方が大きいので、また右に行きます。今度は13と12を比べて13の方が大きいので、ここでは左の子に行きます。つまり、12はこの部分に挿入されることになります。それでは、二分探索木 の挿入の例を見てみます。

以下の二分探索木 に、13, 6, 7, 5の順にデータを挿入してみます。最初に節点 の4よりも小さいので、左の子に行きます。次に2と1を比べて、2よりも小さいので左の子に付けます。ここに挿入されます。次は3です。3は節点 よりも小さいので左に行き、2よりも大きいので右の子になります。このようになります。

次は6です。6は節点 の4よりも大きいので右の子になります。次に7を挿入したいと思います。7は4よりも大きいので右の方を見ます。今度は6と7を比べて、7が大きいので、6の右の子になります。最後に5は節点 の4と比べて5の方が大きいので右の子になり、6と比べて6の方が大きいので、5は6の左の子になります。

別の例を見てみます。今度は二分探索木 に、13, 5, 6, 7の順にデータを挿入します。順番が最後から真ん中に変わっているという状態です。まず1を見ていきます。1は節点 の4と比べて小さいので左の子に行き、2と1を比べて2よりも小さいので左の子に付けます。

次に3です。3は4よりも小さく、2よりも大きいので、2の右の子になります。次に5は4よりも大きいので右の子になります。6は4よりも大きく、5よりも大きいので5の右の子になります。7も4より大きく、5、6よりも大きいので6の右の子になります。

数字は同じでも順番が変われば、二分探索木 の木の形が変わってくるということです。ここで何も考えずにデータを挿入するとバランスが狂ってしまうことがわかります。左の図の二分探索木 は非常にバランスの良い木になっています。

こういった形のものは、高さが log  Nですので処理が早いということです。一方、この右の図のように一列のリストになっているようなものは、高さとしてはオーダーのNになってしまいます。こちらの方が効率が悪いということです。今説明したように、二分探索木 は処理が早いんですけども、ちゃんと二分探索木 の平衡バランスを保ちつつ、データを挿入したり削除したりする必要があります。

二分探索木 のバランスを保ちながらデータの挿入や削除をするにはどうすればいいかというのを考えていきます。ここでは、二分探索木 から削除することを考えましょう。

まずは削除したい節点 の状態で場合分けをしてみます。3つの場合に分けます。1つ目は削除したい節点 に子がない場合、削除したい節点 自体が葉節点 になっている状態です。ケース2は削除したい節点 に子が1つある場合、ケース3は削除したい節点 に子が2つある場合です。

これらそれぞれの場合について考えます。まずはケース1、子を持たない節点 の削除です。この場合は、その節点 を削除するだけで済みます。簡単にできます。例えば137を削除する場合、これで大丈夫です。次にケース2、子を1つ持つ節点 の削除です。例えば、4を削除する場合、4を削除した後に4の子である5または3を4の場所に持っていくだけでいいです。つまり、対象の節点 を削除して親と子をつなげることでできます。これも簡単です。

次はケース3、2つ子を持つ節点 の削除についてです。例えば、ここにある5を消したい場合、この5には子として2と8があります。この場合、まず5の節点 を削除します。そして、ここに適切なものを持ってきて穴を埋めるということになります。

では、適切なものはどれを持ってくればいいかという話になります。先ほどのように開いた穴には何を入れるべきかということですが、開いた穴には直前キーというものを入れます。5を削除するということは、ここは2より大きくて8よりも小さいものでなければならないということです。

もう1つ考えます。例えば14の場合、14を削除する時には、11より大きくて17よりも小さいものでなければならないということです。その考えを踏まえて、直前キーというのを決めます。この直前キーですが、言ったように5のところに入れるのは2より大きく8より小さい値です。

この場合、例えば4が5の直前キーとなります。直前キーというのは削除した節点 の左部分の木のうち、左部分の木の中で最大の要素となりますから、削除した節点 から左下に1つたどり、その後右へ、右へとたどって行き着いた節点 が直前キーというふうになります。

なので、この4を5のところに付け替えると、バランスを崩すことなく二分探索木 を保つことができます。同じようにもし14を削除した場合は、左の14から左に1つたどり、その後右にたどった13が直前キーになります。これを14のところに当てはめることでバランスを保ちます。

今日の話をまとめます。今日はヒープと二分探索木 についてお話しました。ヒープは最大値を取り出すのに非常に有効なデータ構造です。挿入、取り出しともにオーダーの log  Nでできます。応用としてヒープソートなどがあります。

それから二分探索木，これは、木のバランスが良ければ、探索、挿入、削除ともにオーダーの log  Nになります。しかし、バランスが悪い時にはオーダーのNとなり、時間がかかります。ということは、木のバランスを保つための工夫が必要になるということです。特に挿入や削除の時、データの挿入や削除の操作で木のバランスが崩れる可能性があります。

だから、バランスが崩れそうになったら補正する必要があります。ただし、補正に手間をかけすぎるというのも本末転倒になってしまいます。その点を気をつけて、バランスを保ちながら挿入や削除をしていかなければならないということです。

以上で説明を終わります。お疲れ様でした。