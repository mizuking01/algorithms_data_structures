データ構造とアルゴリズム第9週の説明は有明高専の加藤が担当します。これは本コースの講義スケジュールです。今週は先週に引き続きデータの整列について学習します。前回はデータの整列、それからデータを順番に並べるアルゴリズムについて説明し、

基本的なソートアルゴリズムについて紹介しました。ここでは、バブルソート、選択ソート、挿入ソート、シェルソートについて紹介しています。また、第4週で紹介したヒープソートにも触れました。今回はデータ整列の続きになります。

まず高度なソート方法として、マージソートとクイックソートを紹介して、次に整列に必要な最小限の比較回数について考察します。そして最後に比較を用いないソート方法としてバケットソートを紹介します。最初に高度なソート方法の一つとしてマージソートを紹介します。

マージソートは併合ソートとも呼ばれます。マージソートの基本手順ですが、データ列をA、Bの二つに分割して、それぞれのデータ列をソートします。そして、その二つのソート済みデータ列A、Bを一つのソート済みデータXにまとめます。これをマージと言います。マージのアイデアですが、

マージ処理が高速にオーダーのNでできますので、それを利用してソートをします。このマージの計算量について考えてみます。マージ併合はデータ数に比例した手間で済みます。ただし、問題もあります。

マージしたいデータと同じサイズの領域からの領域が別に必要になります。こちらがすでにソート済みの二つのデータ列になります。これをマージして右側の配列に入れていきます。この矢印は今、先頭をどれも指しています。

この矢印がついているところに着目して見ていきます。まず最初、先頭の1と2を比較します。そして小さい方を空の配列の先頭に入れます。そして、こちら側の矢印を一つずらします。また、ここも一つずらしています。次はこの4と2を比べて2が小さいので、この2を、

右側の配列に入れます。そしてまた矢印を動かします。今度は4と3を比べて、3が小さいので、この3を右側の配列に入れます。このようにしていくと小さい順に1、2、3と並んでいきます。次にマージアルゴリズムについて説明します。

マージアルゴリズムはすでにソート済みの二つのデータ列A、Bを一つのソート済みの列Xにまとめるというアルゴリズムです。まず、データ列A、B、Xの現在の位置をそれぞれの先頭とします。そして、AかBの現在地に要素がある限り、

ここから後の処理を繰り返します。AとBの現在位置のうち比較をして、Aの方が小さいならば、Aの現在位置の要素を新しいデータXの列の現在位置に移動します。そして、そのAの現在位置を一つ進めます。そうでない場合、

つまりBの方が小さかったという場合には、Bの現在位置の要素を新しいデータ列のXの現在位置に移動して、Bの現在位置を一つ進めます。そうすると、Xの方にはAかBかどちらかの要素が入りますので、データ列も現在位置を一つ進めます。

これをaとBの両方のデータがすべてなくなるまで処理を繰り返します。次はマージソートの計算手順についてです。ボトムアップ方式のマージソートを考えます。これはマージという考え方をボトムアップに用いて列をソートしようとするアルゴリズムのことです。

まず、長さ1のデータ列からスタートして、隣同士のデータ列の併合を繰り返します。まず、長さ1のデータ列がこのようにあるとすると、この隣同士のデータ列を隣同士のデータを確認して小さい方を左側、大きい方を右側に置きます。そしてさらにこの、

隣同士のデータ列をまた併合します。最終的には一つのデータ列になります。このように細かく分かれたものから、ボトムアップ方式でマージしていった結果、このような並べ替えができました。先ほどのマージソートのアルゴリズムですが、まずデータ列をaとBに分割します。

そして、それぞれのデータ列をマージソートアルゴリズムを用いて再帰的にソートします。つまり、再帰呼び出しをするということです。再帰呼び出しというのは、ある関数からその関数自身を呼び出すということになります。そして、二つのソート済みデータ列ABをマージして、一つのソート済みデータ列Xにまとめます。次に、マージソートの効率について考えます。

データ数Nの場合のマージソートの効率をS(N)とします。ステップ1では、与えられたデータ列を2分割することをやっています。これはオーダーのNでできます。ステップ2は、それぞれのデータ列をマージソートアルゴリズムを用いて再帰的にソートしています。これは2分割されたデータ列をそれぞれ再帰的にソートしてますので、

二つのデータ列かけS(2分のN)になります。ステップ3は、二つのソート済みのデータ列をマージする。これがオーダーのNでできます。これにより、S(N)は2×S(2分のN)＋Nという式が導き出されます。ここでNを2Kと置き、このような式の変形を行っていくと、結果として、

S(N)はオーダーのN log Nとなります。次に高度なソート方法のもう一つのやり方としてクイックソートがあります。このクイックソートはとても有名で、実際にも広く使われています。また、クイックソートはデータ列を一旦分割してまた合わせるという分割統治法の一つです。

クイックソートは1960年、飽和教授が開発しました。有名ですので覚えておくといいと思います。次にクイックソートの手順です。このSがデータ列だとします。データ列の中から基準値Xを選びます。

そしてこのXと他の要素を比べて三つのデータ列に分割します。Xより小さい、Xと等しい、Xより大きい、この三つのデータ列のうちXより小さいのとXより大きいのに関してはソートを行います。そして統合する。このような手順でクイックソートは行っていきます。

具体例を示します。このようなデータ列が与えられたとします。この中で基準を選びます。例えば、3を選んだとすると、この3より小さい、3と等しい、3より大きいというルールで、三つのデータ列に分けます。ここで3より小さいデータ列と3より大きいデータ列は、

それぞれソートします。そしてそれを統合します。このような手順で行っていきます。クイックソートの手順をアルゴリズムで書いてみます。並べたいデータ列をSとしておきます。このSの要素の個数が1より小さければ、Sをそのまま返して終了とします。次にSから要素を一つ選んでXとします。

このXを基準にSを三つのデータ列に分割します。ここでS1と名付けられたものはXより小さいデータが入ります。S2にはXと等しいデータが入ります。S3はXより大きいデータが入ります。ここでS1とS3に関してはクイックソートで再帰的に並べ替えをします。これで、

帰ってきた値S1、S2、S3これを順に連結しておしまいということになります。なお、このステップ3で最終的に呼び出しがありますが、これの停止条件としてはステップ1が設定されています。ここで、

気をつけておかなければならないことは、再帰呼び出しが無限ループに入ってしまわないようにすることです。そこで再帰呼び出しの停止性を確認しておきます。分割後のS1とS3をクイックソートを使ってそれぞれソートします。その際に再帰呼び出しを行います。再帰呼び出しとは、ある関数からその関数自身を呼び出すものです。ここで、

S2というのはS1と同じかそれより大きいものなので、S1とS3というのはSよりは必ずサイズが小さくなります。なので、分割を続けていけば、最終的にはサイズが1以下。データ列の要素数が1個以下になります。

そうなるとそれ以上再帰呼び出しができないということで、再帰呼び出しが停止されます。次に基準値による分割について見てみます。二つに分割するというアイデアですが、これは両端から真ん中に向かって処理を進めるようにします。まず、基準値を設定しておいて、基準値より大きいデータを左から探します。

逆に基準値より小さいデータを探します。そして、左の方に基準値より大きいデータが見つかり、右の方で基準より小さいデータが見つかった場合はこれを入れ替えます。そしてまた、左の方からは基準より大きいデータを探していき、右からは基準より小さいデータを探します。

そしてまた入れ替えをする。これを繰り返していきます。そうすると左の方は基準値以下、右の方は基準値以上の値が入ることになります。この基準値による分割はオーダーのNでできます。先ほどのイメージを具体的な値で見てみたいと思います。

例えば、このような値が準備されているとします。基準値をこの49で分割をしたいと思います。基準値49よりも大きいデータを左側から順番に探します。そうすると90が見つかります。同じように右から49より小さい値を探します。

そうすると15が見つかります。これは入れ替えを行います。そして、その続きからまた基準値49よりも大きいものを調べます。そうすると基準値49のところで止まります。右の方からも今度は49より小さい値を探します。そうすると、

49と47が見つかりますので、この入れ替えをします。そうすると47が左側に、49が右側に入ります。さらに左の方を一つ進めて右側も一つ進めて、ということでここで交差してしまいます。ぶつかってしまいますので、ここで、

分割を終了ということになります。この交差したところ、ここを境界と言います。このように基準より小さいものが左側、大きいものが右側に来ています。次に分割のアルゴリズムについて紹介します。

配列に格納されたいこの整数と分割値Xを与えます。配列の先頭部分にはXより小さい整数だけを、その後にはXより大きい整数だけを格納します。まず場所1は配列の先頭を指し、場所2は配列の末尾を指します。次に、場所1が場所2より前にある限り以下の処理を繰り返します。

まず、場所1の要素がXよりも小さい限り、場所1を一つ進めます。もし場所1の要素がXよりも大きい場合はその場にとどまります。一方、場所2の要素がXよりも大きい限り、場所2を一つ戻します。もし場所2の要素がXよりも小さい場合、その場にとどまります。

そしてどちらも進めなくなったら、場所1の要素と場所2の要素を交換します。交換後、場所1を一つ進め、場所2を一つ戻します。これを繰り返しますが、場所1が場所2より後ろになった場合には処理を終了します。

これが分割のアルゴリズムです。それでは、この分割のアルゴリズムを利用して、クイックソートのアルゴリズムを説明します。まず、相当範囲の要素が2以下の場合には、必要に応じて要素を入れ替えて終了します。そうでなければ、以下の処理を実行します。

まず、分割値、または基準値Xを相当範囲の左側、中央、右端の位置にある要素の中央値とします。次に、Xに基づいて下限と上限の間の要素に分割アルゴリズムを適用し、境界を求めます。そして、下限と境界の間にある要素を再帰的に並べ替えます。これが境界より小さい値を並べ替えていることになります。

さらに、境界プラス1と上限の間にある要素を再帰的に並べ替えます。これは境界より大きい値を再帰的に並べ替えています。ちなみに、この再帰呼び出しの停止条件は、相当範囲の要素数が2以下になったときです。

次に、クイックソートの計算量について考えます。このようにバランスよく分割していけるときは、このステップがオーダーのN log N で済むため、分割に必要な手間の合計はオーダーのN log N ステップになります。

平均的にもオーダーのN log N ステップでできます。ただし、最悪の場合はオーダーのN²ステップになります。この最悪の場合は、各分割で基準値が偶然最大値または最小値だった場合、または分割のバランスが悪い場合です。この場合、オーダーのN²がかかります。

そうならないように基準値の選び方を工夫する必要があります。例えば、先ほど説明したように、両端の値と中央の値、この3つの要素の中央値を採用する方法を「三のメディアによる分割」と言います。こういった選び方を工夫する必要があります。

今までの話を整理します。最初にマージソートについて説明しました。マージ併合を利用しているソートで、常にオーダーのN log N の手間で済みます。しかし、マージのために余分な記憶領域が必要となることが問題点です。次に、クイックソートについても紹介しています。クイックソートは基準値で分割し、分割した部分列を再帰的にソートします。

この計算量は、平均ではオーダーのN log Nですが、分割のバランスが悪ければ最悪オーダーのN²になります。次に、整列に関する比較回数について考察してみましょう。N個のデータを並べ替えるとき、何回の比較が必要か考えてみます。

正しく並べ替えるには必要な情報を得なければなりません。この必要な情報を得るのに、最悪どれだけの手間がかかるのか、比較を用いたソーティングアルゴリズムのオーダーの最小値は何かということを考えます。必要な情報を得るのに比較回数はN回で十分なのか考えてみたいと思います。例えば。

四つのデータを考えてみたいと思います。このabcdというデータには大小関係があり、比較によって特定することができます。例えば、このabcdが2314であれば、aはBより小さい、BはCより大きい、CはDより小さい、aはDより小さいというような大小関係があります。

しかし、この条件だけを見ると、この2314の並び以外にも2413という同じ結果を持つ別のデータ系列が存在してしまいます。つまり、N回の比較では、今回の例では4回でしたが、1位に特定できないことがあります。

つまり、N回の比較だけでは不十分ということです。それではNの二乗回比較すれば十分なのか考えてみます。N個のデータのすべてのペアを比較すれば、これは完全に特定することができます。N個のデータの中のペアの数、これはNC2です。

N個の中から2個選ぶ組み合わせになります。これを解くと、2分のN(N-1)、つまりオーダーのN²で求まります。よって、N²回の比較をすれば十分です。それでは整列に必要な手間について考えます。整列に必要な情報は？

N回の比較では十分な情報が取れません。しかし、2分のN(N-1)回の比較だと十分な情報が得られます。そこで、比較に基づいた整列アルゴリズムは、オーダーのNのアルゴリズムは理論的に不可能です。一方、オーダーのN²のアルゴリズムはできます。実際に実在しています。

ここで、オーダーのN²のアルゴリズムは最適なのか？それから、これ以上オーダーを改善できないのかという疑問が湧きます。先ほどの疑問から、比較回数の限界を考えてみたいと思います。比較回数の限界というのは？

ある問題を解くためのアルゴリズムにおいて、少なくとも何回以上の比較操作が必要かという理論的な限界値のことです。例えば、このようにABCというデータがあります。ABCには大小関係があります。これを小さい順に並べたいと思います。

この段階では、ABCの大小関係はわかっていません。そうなると、Nの階乗通りの可能性、つまりここでは6通りの並べ方の可能性があります。この6通りにおいて、aとBの大小関係がわかると、だいたい半分に絞り込むことができます。例えば、aはBより小さいとなれば、この6通りの中から3つの可能性が出てきます。

また、Bがaより小さいということであれば、このような3つの可能性のあるパターンが出てきます。そして、BとCの大小関係がわかるとさらに絞り込むことができます。例えば、BがCより小さいとなると、このABCの並びは一つになります。

CがBより小さいとなっても、この2通りに絞り込むことができます。下の方も同じです。今の話をまとめると、例えばN個の異なる数字を並べる並べ方を考えると、最初はNの階乗パターンの可能性があります。しかし、一回の比較で可能性をだいたい半分に絞り込むことができます。

そして最終的に一つのパターンに絞り込むには、ログ2のNの階乗回の比較が必要となる場合があります。つまり、最悪の場合にはログ2のNの階乗回の比較が必要です。これはスターリングの公式によりN log_2 Nとなります。

よって、比較回数の下限はオーダーのN log Nとなります。最後に、比較を用いないソート方法としてバケットソートを紹介します。先ほど言ったように、比較を使ったソートアルゴリズムは最低でもオーダーのN log Nかかります。しかし、比較を使わなければ、より高速に、より高い効率でソートができます。

バケットソートには適用条件があります。それは、データ範囲が1からNに限定されているということです。つまり、データとして取り得る値がわかっていないと、これは使えません。バケットソートの手順ですが、1からNの番号をつけた箱を準備します。

そして各データを、そのデータと同じ番号の箱に入れます。そして、1番目の箱から順番にデータを取り出して並べます。非常に単純なやり方です。この時間計算量はオーダーのN+N。これは比較を行わないので効率が良いです。しかし、空間計算量としてはオーダーのN、これは大量のメモリが必要となります。

先ほどの手順はアルゴリズムで表しています。最初にデータを読みます。そして、データXをX番目のバケット、同じ番号のところに入れます。そして、次のデータを読みます。そして、各バケットの各要素についてバケットの要素を表示します。

今回の話をまとめます。最初にマージソートの話をしました。このマージソートは併合マージを利用します。そのため、常にオーダーのN log Nで処理ができます。しかし、問題としてマージのために余分な記憶領域が必要となります。次にクイックソートについて話しました。

クイックソートは基準値で分割して、分割した部分列を再帰的にソートします。この効率ですが、平均としてはオーダーのN log Nですが、最悪の場合、つまり分割のバランスが悪かった場合にはオーダーのN²になります。比較回数の下限はオーダーのN log Nでした。

比較を用いたソートアルゴリズムに関しては、このオーダーのN log Nを持つアルゴリズムが一番早いということになります。最後に比較を使わないソート方法としてバケットソートを紹介しました。これはデータ範囲が1からNに限定、つまりデータが取り得る値があらかじめわかっていないといけないということでした。

このバケットソートは効率が良いのですが、大容量のメモリが必要となります。以上で説明を終わります。お疲れ様でした。