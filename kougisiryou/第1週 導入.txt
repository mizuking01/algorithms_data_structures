以下のように入力文を整形しました：

---

それでは、これからアルゴリズムとデータ構造の授業を始めたいと思います。この授業では、基本的なデータ構造とアルゴリズムの考え方について、概念や考え方、それからアルゴリズムの効率について理解してもらうことが目的です。より具体的に言いますと、まずアルゴリズムの効率を評価するために「尾行機法」と呼ばれる方法があります。アルゴリズムの計算量や記憶量（アルゴリズムが必要とするメモリー容量）を評価できるようになることが一つ目の目標です。

次に、アルゴリズムとデータ構造の相互依存関係を理解できるようになることが二つ目の目標です。アルゴリズムとデータ構造は非常に密接に関連しており、今週と来週の2週間でこれについて説明していきます。

三つ目は、与えられたアルゴリズムの動作を説明できるようになることです。次に、基本的なアルゴリズムを理解できるようになることが目標です。コンピューターサイエンスやプログラミングの問題でよく使われる基本的なアルゴリズムがいくつかあります。この授業では、それらの基本的なアルゴリズムを紹介していきます。これを理解できるようにならないと、効果的なプログラミングを行うことは難しいということです。

同様に、データ構造についても基本的なデータ構造を理解できるようになってもらいます。最後に、アルゴリズムを用いた問題解決を理解することが目標です。プログラミング入門とこのデータ構造・アルゴリズムの概念を理解すると、プログラミングを用いた問題解決ができるようになる仕組みになっています。

この授業は、合計10回で構成されています。今回は、アルゴリズムとデータ構造に関する導入を行い、次回も続きます。その後、探索問題、基本的なデータ構造、動的探索問題を取り上げます。さらに、アルゴリズム演習を飛ばして、データの整列（ソーティング）やグラフアルゴリズムについて2回ずつの授業を行います。これにより、基本的なアルゴリズムとデータ構造を習得してもらう予定です。

今回のビデオで学ぶことは、アルゴリズムとはそもそも何か、データ構造とは何か、そしてアルゴリズムの評価尺度と評価方法についてです。その中で、評価を行う上で重要なのが「陸王機法」や「オーダー記号」と呼ばれるものです。これについて一通り理解し、概念を把握してもらいたいと思います。

では、早速アルゴリズムとは何かについて説明します。アルゴリズムは、与えられた問題を解くための明確に定義された操作からなる有限の手順です。

通常、アルゴリズムは自然言語で記述されます。例えば、日本人の場合は日本語、アメリカ人の場合は英語といったように、自然言語で記述するのが一般的です。プログラミング言語（Python、C++、Javaなど）で記述するのではなく、より抽象的な記述を行います。

プログラムはコンピュータに対して行うべき処理を知らせるためのものですが、アルゴリズムは作成者の意図を記述します。アルゴリズムを読んだ人やプログラムの中に埋め込まれたアルゴリズムが、その作成者の意図を伝えるように記述されます。

この意図を記述することがアルゴリズムの重要なポイントです。また、アルゴリズムは「有限の手順」として定義されています。つまり、アルゴリズムは必ず終了しなければなりません。無限ループのように永遠に終わらないものはアルゴリズムにはならないということです。

さらに、「明確に定義された操作」とは、各操作が明確に定義されており、誰が実行しても同じ結果が得られることを意味します。これを「確定性」と呼びます。

このような条件を満たした手順の記述をアルゴリズムと呼びます。コンピューターサイエンスにはさまざまな問題がありますが、同じ問題に対して複数のアルゴリズムが知られているケースがよくあります。

その場合、アルゴリズムごとに特徴が異なります。例えば、あるアルゴリズムはシンプルですがスピードが遅いのに対し、別のアルゴリズムはスピードが速いけれども複雑です。このように、アルゴリズムにはそれぞれの特徴があり、複数のアルゴリズムを知っておくことが重要です。そして、状況に応じて適切なアルゴリズムを選ぶことがプログラミングをする上で重要です。これを身につけることがこの科目の目的だと考えてください。

例えば、迷路探索問題について説明します。迷路の入り口から出口に至る経路を探す問題です。出口に至る経路があれば、この迷路探索問題には解があるといえます。もし出口にたどり着かない場合、その迷路探索は失敗と見なします。

この経路を探す方法を3種類ほど紹介します。まず、しらみつぶしに探索する方法です。AIがよく用いる方法で、可能なすべての経路を一つ一つ探します。例えば、スタート地点から行くと、まずこの辺りを見て、行き止まりを確認します。次に、別の選択肢を選んで、再び行き止まりを確認します。こうして、一歩一歩進んでいきます。

次に、選択肢が複数出てきた場合、両方の選択肢をしらみつぶしに進めます。例えば、次の選択肢に進むと、こちらも行き止まりだとわかります。その場合、もう一方の選択肢を試し、行き止まりであれば別の経路を探します。

反対側を確認すると、最終的に経路が出口に至ることがわかります。この処理を繰り返すことで、出口に到達できることが明らかになります。したがって、この問題では出口に到達すれば成功です。

もしすべての経路を探索しても出口に到達できない場合、それは失敗と見なします。これが一つ目の方法です。次に、二つ目の方法として「右手法」があります。この方法では、入り口に入ったら常に右手を壁に触れさせて進みます。この場合、右手で壁を触りながら進みます。

右手で壁を触りながら進むと、経路が次のようになります。重要なのは、右手を壁から絶対に離さないことです。右手で触りながら進むと、最終的に出口にたどり着きますが、この方法では回り道が多くなることがあります。しかし、試行錯誤を繰り返しながら最終的に出口に到達します。

出口に到達したら成功です。もし出口が見つからなかった場合、入り口に戻り、失敗となります。これが二つ目の方法です。

三つ目の方法は「行き止まりを埋める」という方法です。この方法では、まず行き止まりのマスを埋めます。例えば、次がないマスを埋めます。埋めたマスによって新たな行き止まりのマスが発生すれば、それも埋めます。こうして、行き止まりが埋まっていきます。これを繰り返すことで、最終的に出口を見つける方法です。

このまっすぐ進むと行き止まりになるのでダメです。こうして操作を繰り返し、すべてのマスが埋まった場合は失敗となります。もしマスが残った場合は成功です。出口まで残ったバスがあれば、出口にたどり着くという仕組みです。

このように、同じ迷路探索問題でも、全く異なる方針で解くことができるのです。次にデータ構造について説明します。

データ構造とは、コンピューターで処理するための対象となるデータを、効率よく組織化して記憶する方法です。例えば、先ほどの迷路も処理対象のデータです。このデータをコンピューターで扱うために、上手に組織化して保存するための方法となっています。

そのための具体的な方法として、プログラミング言語で使われる変数や配列、構造体、またはより高度なものとして連結リスト、スタック、キュー、2分探索木、グラフなどを利用する方法があります。

こちらの写真には、非常に有名なコンピューターサイエンティスト、ニクラウス・ヴィルトさんが示されています。彼は『アルゴリズム＋データ構造＝プログラム』という有名な本を著した人物で、アルゴリズムとデータ構造が相互に依存するという概念を提唱しました。例えば、さっきの迷路探索問題でも、経路図が与えられた時に最短経路を求める問題があります。

例えば、これが街を示すグラフで、AからBまでの距離が1、AからCまでの距離が8、BからCまでの距離が7というように、距離が与えられていると考えます。

例えば、AからEまで行くのに一番速い経路はどのような経路かを考えます。こういったデータが与えられたとき、どのように最短経路を探せるかという問題です。

同じ経路図でも、二次元配列で表現する方法と、一元リストで表現する方法があります。例えば、AとBの距離が1、AとBの距離が1、BとDの距離が3といった感じです。どちらの方法を使用するかは、考える必要があります。

アルゴリズムとは、問題を解くために明確に定義された操作の系列と手順です。データ構造は、処理対象のデータをコンピューターで扱うために上手に組織化して保持する方法です。先ほども言いましたが、同じ問題でも解くアルゴリズムは複数あり、同じデータでも表現するデータ構造は複数あります。

アルゴリズムによって必要なデータ構造は異なります。つまり、アルゴリズムとデータ構造は相互に依存しているということです。

アルゴリズムの良し悪しを測る尺度としては、6つの尺度があります。データ構造とアルゴリズムの中では、正当性（正しく動作するか）、計算時間（短い時間で終了するか）、記憶領域（少ないメモリで動作するか）などに注目して評価します。プログラム全体としては、わかりやすさやプログラムのしやすさ、追加や変更がしやすいことも重要な評価基準となります。

ソフトウェア工学やプログラミングの授業では、こちらの評価尺度に注目して進めていきます。この授業では特に、アルゴリズムとデータ構造の3つに焦点を当てて話を進めていきたいと思います。

基本的に、アルゴリズムの評価には6つの尺度があり、すべてを望ましい状態にすることは簡単ではありません。そのため、うまくバランスを取ることが重要です。一つずつ見ていきますが、まずアルゴリズムの効率についてです。これは、時間計算量、つまり計算にどれくらいの時間がかかるかということ、そして領域計算量、つまりどれくらいのメモリーやハードディスクが必要かという点が重要なポイントになります。

時間計算量と領域計算量は、必要な資源の量が入力サイズに依存するという特徴があります。基本的には、入力データが大きければ大きいほど、より長い時間が必要になります。したがって、計算時間を入力サイズNの関数として表現することにします。

これを計算する際には、具体的なコンピュータに依存するのではなく、仮想的な機械を想定し、入力サイズに対して計算時間がどのくらい増加するかを見ていきます。

Nの値を大きくした時に処理時間がどれくらいかかるのか、特に最悪の場合の値に注目します。例えば、多項式計算を考えた場合、次のような式があります。

N次多項式で、AN、A2、Anなどが係数となります。XゼロがXの具体的な値です。これを入力して多項式の値を計算するとします。

例えば四次式の場合、計算するときに掛け算が4回、足し算が4回行われます。これにより、合計14回の四則演算が必要になります。これに対して、Hornerの方法という賢い方法があります。

この方法では、式をそのまま計算するのではなく、式を変形します。変形すると、掛け算は4回、足し算は4回で済むことがわかります。合計で8回の計算で済むことになります。

さっきの計算方法と比べると、掛け算や四則演算の回数が減っていることがわかります。実際、Nを大きくすると、さらに差が広がります。従来の方法では、掛け算がこのように必要で、足し算はN回となり、計算量はNの二乗に比例します。

一方、Hornerの方法では、掛け算も足し算もそれぞれN回で済むため、計算量はNに比例する程度で済みます。つまり、従来の方法はNの二乗に比例し、オーナーの方法はNに比例するということです。

例えば、Nが1万の場合、1回の演算が10の-6秒（1マイクロ秒）でできると仮定すると、従来の方法では50秒かかりますが、Hornerの方法では0.02秒で済みます。これだけでも圧倒的に速いことがわかります。

このように計算量を比較する際、定数倍の差はあまり気にする必要はありません。むしろ、データ数が増えるにつれて計算時間がどのように増えるかが重要です。アルゴリズムの性能を決める上で、Nに対して定数で進むのか、ログに比例するのか、Nに比例するのか、N log Nに比例するのか、という点が非常に重要になります。

実際、定数はあまり気にしなくても問題ありません。Nの値が十分大きくなれば、追いついてしまうからです。例えば、Nの値に対してlog Nで増える場合、ほとんど増えません。N log NだとNより少し増え、Nの二乗だとNに比べてかなり増えます。三乗だとさらに増えます。

また、Nの二乗やNの階乗といったアルゴリズムもありますが、これらの増え方は非常に急激で、桁違いの数字になります。ちなみに、1.1E+301という数値は、1.1×10の301乗を意味します。

他の例でも、Nの二乗やNの階乗のアルゴリズムは非常に時間がかかることがわかります。多項式時間、例えばログN、N、Nの二乗、Nの三乗程度であれば、計算できる速度としては許容範囲内です。

これに対して、Nの二乗やNの階乗の計算量は指数関数的に増加します。現実的にNが大きくなると、計算が不可能な規模になってしまいます。例えば、Nの二乗であれば10のマイナス四乗の計算量ですが、Nの二乗の場合、4×10の14乗年かかることになります。これでは、いくら高速なコンピューターを使っても終わらないということになります。

コンピュータで解く問題には、多項式時間で解ける問題があります。これらはコンピューターサイエンス的には比較的簡単に解ける問題です。一方で、Nの二乗やNの階乗のように、非常に時間がかかる問題もあります。そして、さらに難しい解けない問題もあります。これらは、アルゴリズムが存在しないと知られている問題です。

アルゴリズムとデータ構造を学ぶことで、こうした問題の難しさがどの程度かを理解することが重要なポイントとなります。

今日は、特に時間に関する評価とオーダーについて話をしました。また、領域、つまりメモリーの消費についても同様の評価を行うことができます。仮想的な計算機で計算を行い、入力サイズに対してどのくらい増加するかを見ていきます。

オーダーの定義を正確に行うと、例えばNゼロの値より大きくなったとき、TNの値がFNの定数倍で抑えられる場合、TNはオーダーのFNであると定義されます。これらの細かい数学的な定義は重要ですが、例えば1万はオーダー1、Nの二乗はオーダーNの二乗ということがわかっています。

アルゴリズムを与えることで、オーダーを評価することができます。例えば、これはN個の整数データの中で最大値を探索するアルゴリズムです。

最初のデータを仮の最大値として設定し、2番目以降のデータを順次見ていきます。そのデータが仮の最大値よりも大きければ、仮の最大値を更新します。最後に残った値が最大値となります。こうしたアルゴリズムです。

これをC++で記述すると、以下のようなプログラムになります。このアルゴリズムのオーダーを計算してみましょう。まず、N個の整数データに対して、オーダーNの時間がかかります。最初のデータを仮の最大値とする処理は、最初のデータだけを見ればよいので、オーダー1、つまり定数時間でできます。

次に、繰り返し処理がN-1回行われ、比較処理も定数時間で済むので、オーダー1です。最後に、最大値を回す処理も定数時間でできます。では、トータルでどうなるかというと、オーダーNに対して、オーダー1が1回、繰り返し処理がN-1回で、最終的にオーダーNとなります。

今日は、オーダーを使ったアルゴリズムの評価方法について説明しました。これを活用して、アルゴリズムを評価することができます。
