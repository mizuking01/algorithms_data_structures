データ構造とアルゴリズム第3週の説明は、有明高専の加藤が担当します。これは本コースの講義スケジュールです。第3週では探索問題について学習します。今回は探索問題とは何かという話をして、さまざまな探索方法について紹介します。まず、探索問題とは？

探索問題とは、データ集合から欲しいデータを探すという問題です。ここでは、5つの探索方法を紹介し、それぞれのアルゴリズムや計算量についても説明します。

探索問題の例として、住所録から「X3」の住所を探す問題を考えます。この表が探索する住所録です。ここで横の一行分がレコード、そしてその一つの要素をフィールドと呼びます。検索に使うフィールドをキーと呼び、探索はこのキーフィールドを探して一致するレコードを探す処理を行います。

これから考える探索問題は、簡単化のために以下の仮定を置いています。整数のキーフィールドが1つだけのデータ集合の中で、指定された整数があるかないかを返す問題です。これを前提に進めていきます。

探索対象のデータ集合の例として、データ構造として一次元の配列を使います。N個の要素を持つ配列を準備し、そこにデータを入力していきます。

次に、探索アルゴリズムのイメージですが、まず並んだ箱の中に数字が1つずつ入っています。その中身を知るには箱を開ける必要があります。箱を開ける回数をなるべく少なくしたいということです。箱を開ける回数が少なければ、効率の良いアルゴリズムということになります。

では、初めに逐次探索について説明します。これは最も単純な探索方法で、配列の要素を先頭から順に調べていく探索です。手間数として配列要素を調べる回数を考えます。例えば、3を探索する場合は、先頭から順に12345と調べるので、5回調べます。

次に5を探索する場合ですが、5はここにあるので、12345678と8回調べます。次に9を探索しますが、9は先頭にあるので1回で見つかります。

最後に2を探索してみます。2を先頭から1つずつ調べますが、見つからなければ最後まで調べて、探索失敗と返します。この場合、回数は9回となります。

次に、逐次探索のアルゴリズムについて説明します。調べたいデータをXとし、探索位置を配列の先頭としておきます。実際の逐次探索はステップ2で行います。まず、探索位置の要素が調べたいデータXと一致したならば、それが見つかったということで探索位置を返して終了します。

もし一致しなければ、探索位置を1つ進めて次の要素を調べることになります。

配列の最後まで調べてみて、見つからなければ探索失敗を返して終了します。次に、逐次探索の効率について説明します。調べたいデータがデータ集合の中で見つかるとき、一番良い場合は一回で見つかります。これは先頭で見つかった時です。次に最悪の場合です。

最悪の場合は、N回調べることになります。これは探したいデータが最後に見つかった場合です。平均の場合は、2分のN回に近いです。オーダーはNとなります。一方、データが見つからない場合も、すべての要素を調べるため、N回となり、オーダーはNです。

ここまでの話を整理します。N要素の配列における探索問題では、基本的に計算量は平均と最悪の場合ともにオーダーNになります。つまり、データの数に比例した時間計算量で、データ数が10倍になれば手間も10倍、100倍になれば手間も100倍になるということです。

次に、順序関係がある場合について考えます。これまでの話は、数字がバラバラに入っている場合を想定していましたが、今回は順序が定義され、その順番でデータが並んでいる場合を考えます。例えば、数字の大小やあいうえお順に並んでいる場合です。

この例では、小さい順に並んでいます。順番通り並んでいるという性質を利用して、効率の良いアルゴリズムを考えてみます。

まず、順序関係を利用した探索の一つ目として、逐次探索の改良版を紹介します。改良版の逐次探索は、探す数字よりも配列中の数字が大きくなった場合、処理をやめるという点が異なります。これによって無駄な探索を省くことができます。

例を示します。例えば、7を調べる場合、先頭から順に1234と調べ、4回目で7が見つかります。この場合、探索成功となり、インデックス3を返します。インデックスは配列の先頭をゼロとするため、0123というようにインデックスは3となります。

次に9を調べる場合、先頭から調べていきますが、配列の要素が10になった時点で処理をやめます。そのため、探索失敗となり、残りはチェックしません。

このように、順序に基づいて後ろを調べなくてよいため、従来の逐次探索とは異なり、無駄な探索を省くことができます。

次に、順序関係を利用した逐次探索の効率について考えます。調べたいデータがデータ集合の中で見つかる場合は、通常の逐次探索と同じです。見つからない場合、一番良い場合は最初の要素よりも調べたいデータが小さい場合です。次に最悪の場合は、N回となります。これは調べたいデータが配列の最後の要素より大きい場合です。平均の場合は、2分のN+1回となります。

順序関係を利用した逐次探索では、無駄な部分をチェックしないため、探索効率は少し改善されますが、オーダーとしては変わりません。これまでの内容を整理します。バラバラに並んだデータを逐次探索する場合、計算量は平均・最悪ともにオーダーNでした。

順序関係を利用した逐次探索でも計算量は平均・最悪ともにオーダーNですが、順序関係を利用することで無駄な部分を探索しないため、より良いアルゴリズムとなります。では、順序関係をさらに賢く利用することで、アルゴリズムを改善できるのではないかと考え、別の探索方法を紹介します。

次に紹介するのはMブロック法です。N個のデータをM個のブロックに分割し、各ブロックはM分のN個の要素を持ちます。調べたいデータに対してM分のN個飛びにチェックをして、可能性のあるブロックを見つけます。そして、そのブロック内のM分のN個を逐次探索します。

例を見てみましょう。ここに15個のデータがあります。このデータを三つのブロックに分割します。すると、一つのブロックは5個の要素を持ちます。この状態で51を探索してみます。まず、51と一つ目のブロックの末尾、8と比べます。51が大きいため、次のブロックの末尾、30と比べます。これでもまだ51が大きいため、51は最後のブロックにある可能性があることがわかります。

そこで、この最後のブロックを逐次探索します。まず、このブロックの先頭、50と比較して、51が大きいので、次の要素を見ます。次の要素は51で、これを見つけることができました。

こうして探索を進めていきます。それでは、Mブロック法のアルゴリズムについて説明します。まず調べたいデータをXとし、ブロック数をMとします。そして、このステップ4を見てください。ステップ4では、調べたいデータがどのブロックにあるかを探します。

ステップ4の1で、当該ブロックの末尾の要素がXの値以上であれば、ループを終了します。そうでなければ、探索位置を次のブロックに進め、最後のブロックを除くブロックについてこの処理を繰り返します。ステップ4では、調べたいデータXとの比較回数は最大でM-1回になります。Mはブロック数です。

比較回数はブロック数から1を引いた回数になります。これは末尾のブロックを除いた回数です。調べるブロックが決まったら、探索位置をそのブロックの先頭に設定します。そして、そのブロックの末尾に到達するまで、ステップ6の1と6の2を繰り返します。

この部分が当該ブロックを逐次探索するアルゴリズムになります。ステップ6の1で、探索中の要素がXの値以上であれば、その要素が見つかったことになりますので、ループを終了します。そうでなければ、探索位置を1つ進めて、次の要素を調べます。このステップ6では、調べたいデータXとの比較回数が最大でM分のN回となります。これは、ブロック長、すなわちこのブロックの長さに対応します。

次に、Mブロック法の効率について説明します。調べたいデータと配列の要素を比較する回数は、先ほど説明したステップ4のブロック数から1を引いた回数と、ステップ6で説明したブロック長（M分のN）に関係しています。M分のNは、実際にはM分のNを最小整数に切り上げた値となります。これを足したものが比較回数となります。

これを変形すると、比較回数が最小となるのはM分のNがMの時です。つまり、MがルートNの時が最小となり、計算量はオーダーのルートNとなります。

ここまでを整理します。今回紹介したMブロック法の計算量はオーダーのルートNです。これは前の逐次探索よりも改善された結果です。

次に、順序関係を利用した探索法として、3つ目の方法、2分探索を紹介します。対象区間を半分に分けながら探索する方法です。例えば、52を探したい場合、まず52と真ん中にある48を比較します。52は48より大きいため、48より後ろの区間に探索範囲を絞ります。

次に、その後ろの区間の真ん中を調べ、これが72です。72と52を比較すると、52は72より前の区間にあると予測できます。さらに、その部分の真ん中と比較し、探索範囲を絞っていきます。このように、一回の比較で探索区間が半分に減少します。

それでは、2分探索法のアルゴリズムについて説明します。調べたいデータをXとします。ステップ1では、Xが配列の先頭要素より小さい、または末尾要素より大きい場合、つまり探索範囲にXがない場合は探索失敗を返すようにします。このステップ3が実際の2分探索を行う部分です。

探索区間が空でない限り、以下の処理を繰り返します。まず、探索区間の中央の要素を求めます。次に、Xが中央の要素より小さい場合、探索範囲の前半部分にXがあるので、探索範囲の末尾を中央のインデックス-1に設定します。そうでなければ、Xは中央より後半の部分にある可能性があるため、探索範囲の先頭を中央のインデックス+1に設定します。これを繰り返し、探索範囲の末尾の要素がXと一致した場合、その末尾の位置を返します。そうでなければ、探索失敗を返します。

これを繰り返してXと一致するものを探していきます。2分探索法の効率ですが、最悪でも計算量はオーダーのログNになります。これは探索範囲がログ2N回の分割で、最終的に大きさが1になります。なぜなら、この分割後の探索範囲の幅はNを2で割ったものとなり、これは1より小さくなるためです。これらの関係から、ログ2N回の分割で大きさが1になるということがわかります。

ここまでを整理すると、2分探索法では計算量がログNとなり、前に紹介したものよりも効率の良いアルゴリズムになっています。特にデータ数が多い場合には、これは効果を発揮します。

最後にハッシュ法について説明します。結論から言うと、ハッシュ法は平均計算時間がオーダー1という、とても効率の良いアルゴリズムです。しかし、N個のデータを格納するために、通常1.5倍から2倍程度の大きさの配列が必要となります。つまり、大きめの配列が必要です。

ハッシュ法の考え方ですが、データXの格納位置をハッシュ関数で求めます。ハッシュ関数は0からM-1（配列の要素数-1）の範囲で定義された関数です。この関数で求めた値をインデックスとしてデータXを配列に格納します。

もし異なるデータXが同じインデックスを持った場合、これは衝突と呼ばれます。その場合、次の空いている位置から探して格納します。探索の場合は、このハッシュ関数で求めた位置から順次探索していきます。

次に、ハッシュ法の具体例を見ていきます。例えば、格納したいデータが5つの数字だとしましょう。

配列として10個の要素を準備し、S₀からSₖにデータを格納していきます。この配列をハッシュ表と呼びます。ハッシュ表にデータを格納するための計算であるハッシュ関数は、XをMで割った余りとして定義します。これにより、格納されたデータは次のようになります。これがハッシュ表です。

それでは、ハッシュ法の具体例を示します。まず、ハッシュ表を作る、つまりデータを登録することを実際に行ってみます。探索対象のデータはここに挙げている5つのデータです。これらを、下のハッシュ表に格納していきます。ハッシュ表は10個の要素を持つ配列です。

まず1つ目の27をハッシュ関数で処理すると、7という値が出ます。したがって、ハッシュ表のインデックス7に格納します。次に11ですが、ハッシュ関数で1という値が出ますので、インデックス1に格納します。同様に、13は3が出るためインデックス3に格納し、10はハッシュ関数で0が出るためインデックス0に格納します。

次に41を考えます。41はハッシュ関数で1が出ますが、インデックス1にはすでに11が入っていますので、右隣の空いている場所に格納します。これが完成したハッシュ表です。

データ登録のアルゴリズムは次のようになります。登録したいデータDに対して、まずハッシュ関数からハッシュ値Jを求め、ハッシュ表のインデックスJを調べます。もしその位置が空いていれば、Dを格納します。空いていない場合は、次の空いている位置を探してDを格納する、という処理を繰り返します。

次に、ハッシュ法で探索をする方法について考えます。例えば13を探したいとき、まずハッシュ関数から値を求めると、13に対応するインデックス3が出ます。インデックス3を調べると、13が見つかるので、インデックス3を返します。

次に41を探す場合、ハッシュ関数で1が出るので、最初にインデックス1を調べます。そこには11が入っており、41ではないので、次の要素を調べます。次に41が見つかり、インデックス2を返します。

次に29を探索する場合、ハッシュ関数で9が出ます。インデックス9を調べますが、ここには空の要素があるため、値が存在しないことがわかります。つまり、探索失敗となり、探索失敗を返します。

最後に12を探す場合、ハッシュ関数で2が出ますので、インデックス2を調べます。そこには41が入っており、12とは異なります。次にインデックス3を調べますが、そこには13が入っています。次に空の位置まで調べた結果、12が見つからないため、探索失敗を返します。

このデータ探索アルゴリズムを示します。調べたいデータをXとし、最初にXのハッシュ値Jを求めます。次に、そのJを探索位置としてハッシュ表を調べていきます。探索位置の要素がXと一致した場合、探索位置を返しますが、そうでなければ次の要素を調べます。

探索位置が空でない限り、この処理を繰り返します。しかし、調べた要素が空であった場合、探索失敗を返します。

ハッシュ法の効率について説明します。平均成功探索回数および平均不成功探索回数はそれぞれ次のようになります。ここで、Aの値はハッシュ表の占有率を示しています。このハッシュ法はデータ量には依存しません。依存しているのはハッシュ表の占有率です。

もしハッシュ表の占有率が1に比べて十分小さければ、平均1回の比較で済むため、オーダー1の計算量となります。

次に、効率が悪くなる状況を考えてみます。探索対象のデータがハッシュ関数で計算したときにすべて同じ値になる場合です。この場合、全てのデータは同じ位置に格納されます。例えば、11は1に登録されますが、51はその次、31はさらにその次の位置に格納されます。

例えば、21を探したい場合、ハッシュ関数で1という値が出ても、インデックス1を調べても見つからず、その隣を探しても見つかりません。次々と探していき、最終的に最後の要素で見つかります。この場合、N個すべての要素を確認する必要があり、計算量としてオーダーNがかかります。

ただし、この問題を回避する方法もあります。例えば、元々のハッシュ表の配列を大きくしておけば、このような衝突（同じ位置に登録しようとする現象）がなくなり、結果として計算量を下げることができます。

今日の話をまとめます。今日は探索問題について話をしました。また、探索の方法としてここに挙げている5つを紹介しました。バラバラのデータを扱う逐次探索は、平均・最悪ともにオーダーNの計算量です。未登録データを探索する場合、すべての要素の確認が必要です。

次に、順序関係を利用した探索方法として、逐次探索の改良版、Nブロック法、2分探索法を紹介しました。

逐次探索の改良版でも計算量はオーダーNでした。Mブロック法はオーダーの√N、2分探索法はオーダーのlog Nという計算量です。

最後にハッシュ法について説明しました。これはハッシュ表にハッシュ関数を用いてデータを登録し、オーダー1で計算・比較を行います。最悪の場合も考慮しましたが、配列を大きく取ることでその問題は回避できます。

これら4つの探索方法では、未登録データを探索した場合でもすべての要素を確認することはありません。最初の逐次探索に比べて、効率の良いアルゴリズムになっていると考えられます。

以上で説明を終わります。お疲れ様でした。